# 配置中心化管理设计方案

**版本**: 1.0
**日期**: 2025-09-16
**状态**: 设计阶段（尚未实施）

## 一、现状分析

### 1.1 配置分散问题诊断

通过深度分析，发现系统配置分散在多个位置：

#### 配置文件分散（7个目录）
```
/config/
├── cookies.json
├── download_settings.json
├── monitor_config.json
├── real_documents.json
└── schedule_tasks.json

/production/config/
├── real_documents.json（重复）
└── (其他配置)

硬编码配置：
- standard_columns_config.py（列定义）
- comparison_to_scoring_adapter.py（L1/L2/L3分类）
- comprehensive_score_generator_v2.py（权重参数）
- final_heatmap_server.py（UI配置）
```

#### 配置重复问题
- `real_documents.json` 在2个位置
- 列定义在规范文档、Python文件、多处代码中重复
- L1/L2/L3分类在多个文件中硬编码

#### 配置不一致风险
- 20个文件引用`STANDARD_COLUMNS`
- 多个adapter实现不同的列映射逻辑
- 打分算法参数分散在各处

### 1.2 影响评估

| 问题 | 影响程度 | 风险等级 |
|------|---------|---------|
| 配置修改困难 | 高 | L1 |
| 版本不一致 | 高 | L1 |
| 维护成本高 | 中 | L2 |
| 缺少验证机制 | 中 | L2 |
| 难以追踪变更 | 低 | L3 |

---

## 二、设计目标

### 2.1 核心目标
1. **单一数据源**：每个配置项只在一处定义
2. **集中管理**：所有配置通过统一接口访问
3. **动态加载**：支持运行时重载配置
4. **版本控制**：配置变更可追溯
5. **类型安全**：配置项类型验证

### 2.2 设计原则
- **最小侵入**：不大幅修改现有代码
- **向后兼容**：保持现有API不变
- **渐进迁移**：分阶段实施
- **配置即代码**：配置文件版本化管理

---

## 三、架构设计

### 3.1 配置层次结构

```
┌─────────────────────────────────────────────┐
│            配置中心（Config Center）          │
├─────────────────────────────────────────────┤
│                                             │
│  ┌─────────────┐  ┌─────────────┐         │
│  │ 静态配置     │  │ 动态配置     │         │
│  │ (不常变)     │  │ (可能变化)   │         │
│  └─────────────┘  └─────────────┘         │
│         ↓                ↓                  │
│  ┌──────────────────────────────┐          │
│  │     统一配置加载器             │          │
│  │   (ConfigLoader)              │          │
│  └──────────────────────────────┘          │
│         ↓                                   │
│  ┌──────────────────────────────┐          │
│  │     配置验证器                 │          │
│  │   (ConfigValidator)           │          │
│  └──────────────────────────────┘          │
│         ↓                                   │
│  ┌──────────────────────────────┐          │
│  │     配置访问接口               │          │
│  │   (ConfigAccessor)            │          │
│  └──────────────────────────────┘          │
│                                             │
└─────────────────────────────────────────────┘
```

### 3.2 配置分类设计

#### 静态配置（构建时确定）
```yaml
# /config/static/columns.yaml
columns:
  standard_columns:
    - name: "序号"
      index: 0
      level: "L3"
      type: "string"
      width: 60

  l1_columns: ["来源", "任务发起时间", ...]
  l2_columns: ["项目类型", "具体计划内容", ...]
  l3_columns: ["序号", "完成链接", ...]
```

#### 动态配置（运行时可变）
```yaml
# /config/dynamic/scoring.yaml
scoring:
  weights:
    重要程度: 1.4
    任务发起时间: 1.3
    预计完成时间: 1.3

  thresholds:
    L1_min: 0.8
    L2_min: 0.6

  diffusion:
    rate: 0.08
    iterations: 3
```

### 3.3 统一配置管理器设计

```python
# /root/projects/tencent-doc-manager/config/config_center.py

class ConfigCenter:
    """配置中心 - 单例模式"""

    _instance = None
    _config_cache = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        self.base_dir = Path("/root/projects/tencent-doc-manager/config")
        self.static_dir = self.base_dir / "static"
        self.dynamic_dir = self.base_dir / "dynamic"
        self.load_all_configs()

    def load_all_configs(self):
        """加载所有配置文件"""
        # 加载静态配置
        self._load_static_configs()
        # 加载动态配置
        self._load_dynamic_configs()
        # 验证配置完整性
        self._validate_configs()

    def get(self, key: str, default=None):
        """获取配置项"""
        keys = key.split('.')
        value = self._config_cache

        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
                if value is None:
                    return default
            else:
                return default

        return value

    def reload(self, config_type: str = None):
        """重新加载配置"""
        if config_type == "static":
            self._load_static_configs()
        elif config_type == "dynamic":
            self._load_dynamic_configs()
        else:
            self.load_all_configs()

    def validate(self, schema_file: str = None):
        """验证配置符合schema"""
        # 使用JSON Schema或其他验证工具
        pass
```

### 3.4 配置访问适配器

```python
# /root/projects/tencent-doc-manager/config/adapters.py

class ColumnConfigAdapter:
    """列配置适配器 - 提供向后兼容接口"""

    def __init__(self):
        self.config_center = ConfigCenter()

    @property
    def STANDARD_COLUMNS(self):
        """兼容旧代码的属性访问"""
        return self.config_center.get('columns.standard_columns')

    @property
    def L1_COLUMNS(self):
        return self.config_center.get('columns.l1_columns')

    @property
    def L2_COLUMNS(self):
        return self.config_center.get('columns.l2_columns')

    @property
    def L3_COLUMNS(self):
        return self.config_center.get('columns.l3_columns')

# 全局实例
column_config = ColumnConfigAdapter()
```

---

## 四、配置文件组织结构

### 4.1 目录结构设计

```
/config/
├── static/                    # 静态配置（不常变）
│   ├── columns.yaml          # 列定义
│   ├── risk_levels.yaml      # 风险等级
│   └── ui_layout.yaml        # UI布局
│
├── dynamic/                   # 动态配置（可能变化）
│   ├── scoring.yaml          # 打分参数
│   ├── rendering.yaml        # 渲染参数
│   ├── cookies.json          # Cookie存储
│   └── documents.yaml        # 文档配置
│
├── schemas/                   # 配置验证模式
│   ├── columns.schema.json
│   └── scoring.schema.json
│
├── backup/                    # 配置备份
│   └── {timestamp}/
│
└── config_center.py          # 配置中心实现
```

### 4.2 配置文件格式选择

| 格式 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| YAML | 可读性好，支持注释 | 需要额外库 | 复杂配置 |
| JSON | 原生支持，标准格式 | 不支持注释 | API配置 |
| TOML | 简洁，类型明确 | 生态较小 | 应用配置 |
| Python | 灵活，可编程 | 安全风险 | 特殊逻辑 |

**建议**：YAML为主（人类可读），JSON为辅（程序交互）

---

## 五、迁移策略

### 5.1 分阶段实施计划

#### Phase 1：准备阶段（1天）
1. 创建配置目录结构
2. 编写ConfigCenter基础代码
3. 创建配置验证schemas

#### Phase 2：静态配置迁移（2天）
1. 迁移STANDARD_COLUMNS到columns.yaml
2. 迁移L1/L2/L3分类
3. 更新standard_columns_config.py为适配器

#### Phase 3：动态配置迁移（2天）
1. 迁移打分算法参数
2. 迁移渲染参数
3. 整合现有JSON配置

#### Phase 4：代码适配（3天）
1. 修改主要模块使用ConfigCenter
2. 保持向后兼容接口
3. 添加配置热重载支持

#### Phase 5：测试验证（2天）
1. 单元测试
2. 集成测试
3. 性能测试

### 5.2 向后兼容策略

```python
# 兼容层示例
# 原代码：from standard_columns_config import STANDARD_COLUMNS
# 新代码：自动适配

# standard_columns_config.py (修改后)
from config.config_center import ConfigCenter

config = ConfigCenter()

# 保持原有接口
STANDARD_COLUMNS = config.get('columns.standard_columns')
L1_COLUMNS = config.get('columns.l1_columns')
L2_COLUMNS = config.get('columns.l2_columns')
L3_COLUMNS = config.get('columns.l3_columns')

# 原有函数继续工作
def get_standard_columns():
    return STANDARD_COLUMNS.copy()
```

---

## 六、技术实现细节

### 6.1 配置加载优化

```python
class LazyConfigLoader:
    """延迟加载配置"""

    def __init__(self, config_file):
        self.config_file = config_file
        self._config = None

    @property
    def config(self):
        if self._config is None:
            self._config = self._load_config()
        return self._config

    def _load_config(self):
        # 加载并缓存配置
        pass
```

### 6.2 配置变更通知

```python
class ConfigObserver:
    """配置变更观察者"""

    def __init__(self):
        self.observers = []

    def register(self, callback):
        self.observers.append(callback)

    def notify_change(self, config_key, old_value, new_value):
        for observer in self.observers:
            observer(config_key, old_value, new_value)
```

### 6.3 配置验证机制

```python
def validate_config(config_data, schema):
    """使用JSON Schema验证配置"""
    import jsonschema

    try:
        jsonschema.validate(config_data, schema)
        return True, None
    except jsonschema.ValidationError as e:
        return False, str(e)
```

---

## 七、风险评估与缓解

### 7.1 技术风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|-------|------|---------|
| 配置加载失败 | 低 | 高 | 默认配置备份 |
| 性能下降 | 中 | 中 | 缓存机制 |
| 向后兼容问题 | 中 | 高 | 适配器模式 |
| 配置冲突 | 低 | 中 | 验证机制 |

### 7.2 实施风险

- **大量代码修改**：使用适配器模式最小化修改
- **测试不充分**：分阶段实施，每阶段充分测试
- **文档不同步**：自动生成配置文档

---

## 八、预期收益

### 8.1 短期收益
- 配置修改更简单
- 减少配置错误
- 提高开发效率

### 8.2 长期收益
- 降低维护成本
- 支持多环境部署
- 便于配置审计
- 支持A/B测试

---

## 九、实施检查清单

### 前置条件
- [ ] 备份所有现有配置文件
- [ ] 梳理所有配置项清单
- [ ] 确定配置优先级

### 实施步骤
- [ ] 创建配置中心代码框架
- [ ] 迁移静态配置
- [ ] 迁移动态配置
- [ ] 创建适配器层
- [ ] 更新主要模块
- [ ] 编写单元测试
- [ ] 执行集成测试
- [ ] 更新文档

### 验收标准
- [ ] 所有配置集中管理
- [ ] 无硬编码配置
- [ ] 向后兼容性100%
- [ ] 配置验证通过率100%
- [ ] 性能无明显下降

---

## 十、附录

### A. 配置项清单

```yaml
# 完整配置项列表
configs:
  static:
    - columns.standard_columns
    - columns.l1_columns
    - columns.l2_columns
    - columns.l3_columns
    - risk_levels.definitions
    - ui_layout.heatmap

  dynamic:
    - scoring.weights
    - scoring.thresholds
    - rendering.idw_params
    - rendering.diffusion_params
    - documents.list
    - cookies.data
```

### B. 配置Schema示例

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "columns": {
      "type": "object",
      "properties": {
        "standard_columns": {
          "type": "array",
          "items": {"type": "string"},
          "minItems": 19,
          "maxItems": 19
        }
      },
      "required": ["standard_columns"]
    }
  }
}
```

### C. 迁移脚本示例

```python
# migrate_configs.py
def migrate_hardcoded_configs():
    """迁移硬编码配置到配置文件"""

    # 收集所有硬编码配置
    configs = collect_hardcoded_configs()

    # 转换为YAML格式
    yaml_configs = convert_to_yaml(configs)

    # 保存到配置目录
    save_configs(yaml_configs)

    # 生成适配器代码
    generate_adapters()
```

---

**设计说明**: 本方案为设计阶段文档，实施前需进行详细评审和风险评估。建议先在测试环境验证，确认无误后再应用到生产环境。
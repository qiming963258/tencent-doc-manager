#!/usr/bin/env python3
"""
详细打分生成器 - 符合0000标准
从CSV对比差异生成详细打分文件
"""

import json
import os
import sys
from datetime import datetime
from collections import defaultdict
import random

# 添加项目路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# 19个标准列名（从0000标准文档）
STANDARD_COLUMNS = [
    "序号", "项目类型", "来源", "任务发起时间", "目标对齐",
    "关键KR对齐", "具体计划内容", "邓总指导登记", "负责人",
    "协助人", "监督人", "重要程度", "预计完成时间", "完成进度",
    "形成计划清单", "复盘时间", "对上汇报", "应用情况", "进度分析总结"
]

# 列级别定义（根据0000标准）
L1_COLUMNS = ["序号", "项目类型", "目标对齐", "关键KR对齐"]
L2_COLUMNS = ["负责人", "协助人", "监督人", "预计完成时间", "完成进度", "重要程度"]
L3_COLUMNS = ["邓总指导登记", "形成计划清单", "复盘时间", "对上汇报", "应用情况", "进度分析总结", "具体计划内容", "任务发起时间", "来源"]

class DetailedScoreGenerator:
    """详细打分生成器"""

    def __init__(self):
        """初始化生成器"""
        self.scoring_standard = "0000-颜色和级别打分标准"

    def get_column_level(self, column_name):
        """获取列的风险级别"""
        if column_name in L1_COLUMNS:
            return "L1"
        elif column_name in L2_COLUMNS:
            return "L2"
        else:
            return "L3"

    def calculate_score(self, column_level, old_value, new_value):
        """
        计算单个修改的打分
        根据0000标准：
        - L1列：最低分0.8
        - L2列：最低分0.4（需要AI评估）
        - L3列：最低分0.1
        """
        # 基础打分
        if column_level == "L1":
            base_score = 0.8
            # L1列的打分范围：0.8-1.0
            variation = random.uniform(0, 0.2)
            score = min(1.0, base_score + variation)
        elif column_level == "L2":
            base_score = 0.4
            # L2列的打分范围：0.4-0.7
            # 模拟AI评估的结果
            if self.simulate_ai_evaluation(old_value, new_value):
                variation = random.uniform(0.2, 0.3)  # AI认为风险较高
            else:
                variation = random.uniform(0, 0.2)    # AI认为风险较低
            score = min(0.7, base_score + variation)
        else:  # L3
            base_score = 0.1
            # L3列的打分范围：0.1-0.4
            variation = random.uniform(0, 0.3)
            score = min(0.4, base_score + variation)

        return round(score, 3)

    def simulate_ai_evaluation(self, old_value, new_value):
        """
        模拟AI评估（实际项目中应调用真实AI接口）
        返回True表示高风险，False表示低风险
        """
        # 简单的模拟逻辑
        if old_value and new_value:
            # 如果变化很大，认为是高风险
            if len(str(new_value)) > len(str(old_value)) * 2:
                return True
            if str(old_value).isdigit() and str(new_value).isdigit():
                # 数字变化超过50%认为高风险
                try:
                    old_num = float(old_value)
                    new_num = float(new_value)
                    if old_num > 0:
                        change_rate = abs(new_num - old_num) / old_num
                        return change_rate > 0.5
                except:
                    pass

        # 默认返回随机结果（30%概率高风险）
        return random.random() < 0.3

    def generate_detailed_score(self, table_name, table_id, diff_file_path, output_dir=None):
        """
        生成单个表格的详细打分

        参数：
        - table_name: 表格名称
        - table_id: 表格ID
        - diff_file_path: CSV对比差异文件路径
        - output_dir: 输出目录
        """
        # 加载差异文件
        with open(diff_file_path, 'r', encoding='utf-8') as f:
            diff_data = json.load(f)

        differences = diff_data.get('differences', [])
        comparison_summary = diff_data.get('comparison_summary', {})

        # 初始化详细打分结构
        detailed_score = {
            "metadata": {
                "table_id": table_id,
                "table_name": table_name,
                "generation_time": datetime.now().isoformat(),
                "scoring_standard": self.scoring_standard,
                "scoring_version": "2.0"
            },
            "comparison_info": {
                "baseline_file": comparison_summary.get('baseline_file', ''),
                "current_file": comparison_summary.get('current_file', ''),
                "total_rows": comparison_summary.get('rows_compared', 50),
                "total_columns": 19,
                "comparison_time": comparison_summary.get('comparison_time', '')
            },
            "modifications_summary": {
                "total_modifications": len(differences),
                "high_risk_count": 0,    # ≥0.6
                "medium_risk_count": 0,   # ≥0.4
                "low_risk_count": 0       # <0.4
            },
            "column_scores": {},
            "detailed_modifications": []
        }

        # 按列组织修改
        column_modifications = defaultdict(list)

        # 处理每个差异
        for diff in differences:
            col_name = diff.get('列名', '')
            row_num = diff.get('行号', 1)
            old_value = diff.get('原值', '')
            new_value = diff.get('新值', '')

            if col_name in STANDARD_COLUMNS:
                # 获取列级别和计算打分
                col_level = self.get_column_level(col_name)
                score = self.calculate_score(col_level, old_value, new_value)

                # 记录修改详情
                modification = {
                    "row": row_num,
                    "column": col_name,
                    "column_level": col_level,
                    "old_value": str(old_value),
                    "new_value": str(new_value),
                    "score": score,
                    "risk_level": self.get_risk_level(score)
                }

                # 如果是L2列，添加AI决策信息
                if col_level == "L2":
                    modification["ai_decision"] = "APPROVE" if score < 0.5 else "REVIEW"
                    modification["ai_confidence"] = round(random.uniform(0.7, 0.95), 2)

                detailed_score["detailed_modifications"].append(modification)
                column_modifications[col_name].append(modification)

                # 更新风险统计
                if score >= 0.6:
                    detailed_score["modifications_summary"]["high_risk_count"] += 1
                elif score >= 0.4:
                    detailed_score["modifications_summary"]["medium_risk_count"] += 1
                else:
                    detailed_score["modifications_summary"]["low_risk_count"] += 1

        # 生成每列的汇总信息
        for col_name in STANDARD_COLUMNS:
            mods = column_modifications.get(col_name, [])
            if mods:
                scores = [m["score"] for m in mods]
                rows = [m["row"] for m in mods]

                detailed_score["column_scores"][col_name] = {
                    "column_level": self.get_column_level(col_name),
                    "modifications": len(mods),
                    "modified_rows": sorted(rows),
                    "row_scores": scores,
                    "avg_score": round(sum(scores) / len(scores), 3),
                    "max_score": max(scores),
                    "min_score": min(scores)
                }

                # L2列添加AI决策汇总
                if self.get_column_level(col_name) == "L2":
                    ai_decisions = [m.get("ai_decision", "UNKNOWN") for m in mods]
                    detailed_score["column_scores"][col_name]["ai_decisions"] = {
                        "APPROVE": ai_decisions.count("APPROVE"),
                        "REVIEW": ai_decisions.count("REVIEW")
                    }

        # 计算表格整体风险分数
        if detailed_score["detailed_modifications"]:
            all_scores = [m["score"] for m in detailed_score["detailed_modifications"]]
            detailed_score["overall_risk_score"] = round(sum(all_scores) / len(all_scores), 3)
        else:
            detailed_score["overall_risk_score"] = 0.0

        # 保存详细打分文件
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = os.path.join(output_dir, f"detailed_score_{table_name}_{timestamp}.json")

            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(detailed_score, f, ensure_ascii=False, indent=2)

            print(f"✅ 详细打分文件已生成: {output_file}")
            return output_file, detailed_score

        return None, detailed_score

    def get_risk_level(self, score):
        """根据打分获取风险等级描述"""
        if score >= 0.8:
            return "极高风险"
        elif score >= 0.6:
            return "高风险"
        elif score >= 0.4:
            return "中风险"
        elif score >= 0.1:
            return "低风险"
        else:
            return "极低风险"

    def batch_generate(self, output_dir="/root/projects/tencent-doc-manager/scoring_results/detailed"):
        """批量生成所有表格的详细打分"""
        diff_dir = "/root/projects/tencent-doc-manager/csv_versions/standard_outputs"

        # 真实业务表格名称列表
        table_names = [
            "小红书内容审核记录表",
            "小红书商业化收入明细表",
            "企业风险评估矩阵表",
            "小红书内容创作者等级评定表",
            "财务月度报表汇总表",
            "小红书社区运营活动表",
            "项目风险登记管理表",
            "项目资源分配计划表",
            "合规检查问题跟踪表",
            "项目质量检查评估表",
            "小红书品牌合作审批表",
            "内部审计问题整改表",
            "小红书用户投诉处理表",
            "供应商评估管理表",
            "小红书内容质量评分表",
            "员工绩效考核记录表",
            "小红书广告效果分析表",
            "客户满意度调查表",
            "小红书社区违规处理表",
            "产品需求优先级列表",
            "小红书KOL合作跟踪表",
            "技术债务管理清单",
            "小红书内容趋势分析表",
            "运营数据周报汇总表",
            "小红书用户画像分析表",
            "市场竞品对比分析表",
            "小红书商品销售统计表",
            "系统性能监控报表",
            "小红书内容标签管理表",
            "危机事件应对记录表"
        ]

        generated_files = []

        for i in range(1, 31):
            diff_file = os.path.join(diff_dir, f"table_{i:03d}_diff.json")
            if os.path.exists(diff_file):
                table_name = table_names[i-1] if i <= len(table_names) else f"表格{i}"
                print(f"处理表格 {i}: {table_name}")

                output_file, _ = self.generate_detailed_score(
                    table_name=table_name,
                    table_id=i-1,
                    diff_file_path=diff_file,
                    output_dir=output_dir
                )

                if output_file:
                    generated_files.append(output_file)

        print(f"\n✅ 批量生成完成，共生成 {len(generated_files)} 个详细打分文件")
        return generated_files

def main():
    """主函数"""
    generator = DetailedScoreGenerator()

    # 批量生成所有详细打分
    generator.batch_generate()

if __name__ == "__main__":
    main()
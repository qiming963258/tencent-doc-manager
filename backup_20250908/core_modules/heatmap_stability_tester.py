#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Stage 5: ÁÉ≠ÂäõÂõæÁÆóÊ≥ïÁ®≥ÂÆöÊÄßÊµãËØïÂô®
Á°Æ‰øùÁÉ≠ÂäõÂõæÁÆóÊ≥ïÂú®ÂêÑÁßçÊù°‰ª∂‰∏ã‰øùÊåÅÁ®≥ÂÆöÊÄßËÉΩ
"""

import sys
import os
sys.path.append('/root/projects/tencent-doc-manager/production/core_modules')

import asyncio
import time
import json
import logging
import math
import requests
from datetime import datetime
from typing import Dict, List, Tuple, Optional
from concurrent.futures import ThreadPoolExecutor
import statistics

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class HeatmapStabilityTester:
    """
    ÁÉ≠ÂäõÂõæÁÆóÊ≥ïÁ®≥ÂÆöÊÄßÊµãËØïÂô®
    ÊµãËØïÈ´òÊñØÂπ≥Êªë„ÄÅÊï∞ÊçÆÁîüÊàê„ÄÅAPIÂìçÂ∫îÁ≠âÊ†∏ÂøÉÂäüËÉΩ
    """
    
    def __init__(self, base_url: str = "http://localhost:8089"):
        """ÂàùÂßãÂåñÁ®≥ÂÆöÊÄßÊµãËØïÂô®"""
        self.base_url = base_url
        self.test_results = []
        self.performance_metrics = {
            'api_response_times': [],
            'data_generation_times': [],
            'memory_usage': [],
            'algorithm_accuracy': [],
            'stability_score': 0.0
        }
        
        logger.info("‚úÖ ÁÉ≠ÂäõÂõæÁ®≥ÂÆöÊÄßÊµãËØïÂô®ÂàùÂßãÂåñÂÆåÊàê")
    
    def gaussian_smoothing_test(self, matrix: List[List[float]]) -> Dict:
        """ÊµãËØïÈ´òÊñØÂπ≥ÊªëÁÆóÊ≥ïÁöÑÁ®≥ÂÆöÊÄß"""
        try:
            start_time = time.time()
            
            # ÂàõÂª∫È´òÊñØÊ†∏ÂáΩÊï∞
            def gaussian_kernel(size: int, sigma: float) -> List[List[float]]:
                kernel = [[0.0 for _ in range(size)] for _ in range(size)]
                center = size // 2
                total = 0.0
                
                for y in range(size):
                    for x in range(size):
                        distance = ((x - center) ** 2 + (y - center) ** 2) ** 0.5
                        value = math.exp(-(distance ** 2) / (2 * (sigma ** 2)))
                        kernel[y][x] = value
                        total += value
                
                # Ê†áÂáÜÂåñÊ†∏
                for y in range(size):
                    for x in range(size):
                        kernel[y][x] /= total
                        
                return kernel
            
            # Â∫îÁî®È´òÊñØÂπ≥Êªë
            def apply_gaussian_smooth(data: List[List[float]], kernel_size: int = 5, sigma: float = 1.5) -> List[List[float]]:
                kernel = gaussian_kernel(kernel_size, sigma)
                height = len(data)
                width = len(data[0])
                result = [[0.0 for _ in range(width)] for _ in range(height)]
                padding = kernel_size // 2
                
                for y in range(height):
                    for x in range(width):
                        weighted_sum = 0.0
                        weight_total = 0.0
                        
                        for ky in range(kernel_size):
                            for kx in range(kernel_size):
                                dy = y + ky - padding
                                dx = x + kx - padding
                                
                                if 0 <= dy < height and 0 <= dx < width:
                                    weight = kernel[ky][kx]
                                    weighted_sum += data[dy][dx] * weight
                                    weight_total += weight
                        
                        result[y][x] = weighted_sum / weight_total if weight_total > 0 else 0.0
                
                return result
            
            # ÊâßË°åÂπ≥ÊªëÁÆóÊ≥ï
            smoothed_matrix = apply_gaussian_smooth(matrix)
            processing_time = time.time() - start_time
            
            # ËÆ°ÁÆóÂπ≥ÊªëÊïàÊûúÊåáÊ†á
            original_values = [cell for row in matrix for cell in row]
            smoothed_values = [cell for row in smoothed_matrix for cell in row]
            
            original_variance = statistics.variance(original_values) if len(original_values) > 1 else 0
            smoothed_variance = statistics.variance(smoothed_values) if len(smoothed_values) > 1 else 0
            smoothing_ratio = original_variance / max(smoothed_variance, 0.001)
            
            # ËæπÁºò‰øùÊåÅÊµãËØï
            edge_preservation = self._calculate_edge_preservation(matrix, smoothed_matrix)
            
            return {
                'success': True,
                'processing_time': processing_time,
                'smoothing_ratio': smoothing_ratio,
                'edge_preservation': edge_preservation,
                'matrix_size': f"{len(matrix)}x{len(matrix[0])}",
                'algorithm_stability': 'stable' if processing_time < 0.1 and smoothing_ratio > 1.0 else 'unstable'
            }
            
        except Exception as e:
            logger.error(f"È´òÊñØÂπ≥ÊªëÊµãËØïÂ§±Ë¥•: {e}")
            return {
                'success': False,
                'error': str(e),
                'algorithm_stability': 'failed'
            }
    
    def _calculate_edge_preservation(self, original: List[List[float]], smoothed: List[List[float]]) -> float:
        """ËÆ°ÁÆóËæπÁºò‰øùÊåÅÂ∫¶"""
        try:
            height = len(original)
            width = len(original[0])
            
            # ËÆ°ÁÆóÊ¢ØÂ∫¶
            original_gradients = []
            smoothed_gradients = []
            
            for y in range(1, height-1):
                for x in range(1, width-1):
                    # ÂéüÂßãÊ¢ØÂ∫¶
                    orig_grad_x = original[y][x+1] - original[y][x-1]
                    orig_grad_y = original[y+1][x] - original[y-1][x]
                    orig_grad = (orig_grad_x**2 + orig_grad_y**2)**0.5
                    original_gradients.append(orig_grad)
                    
                    # Âπ≥ÊªëÂêéÊ¢ØÂ∫¶
                    smooth_grad_x = smoothed[y][x+1] - smoothed[y][x-1]
                    smooth_grad_y = smoothed[y+1][x] - smoothed[y-1][x]
                    smooth_grad = (smooth_grad_x**2 + smooth_grad_y**2)**0.5
                    smoothed_gradients.append(smooth_grad)
            
            # ËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß
            if len(original_gradients) > 0:
                # ËÆ°ÁÆóÁöÆÂ∞îÈÄäÁõ∏ÂÖ≥Á≥ªÊï∞
                n = len(original_gradients)
                sum_x = sum(original_gradients)
                sum_y = sum(smoothed_gradients)
                sum_xx = sum(x*x for x in original_gradients)
                sum_yy = sum(y*y for y in smoothed_gradients)
                sum_xy = sum(x*y for x, y in zip(original_gradients, smoothed_gradients))
                
                numerator = n * sum_xy - sum_x * sum_y
                denominator = ((n * sum_xx - sum_x**2) * (n * sum_yy - sum_y**2))**0.5
                
                if denominator > 0:
                    correlation = numerator / denominator
                    return max(0.0, correlation)  # ËøîÂõûÊ≠£Áõ∏ÂÖ≥ÊÄß
                else:
                    return 0.0
            else:
                return 0.0
                
        except Exception:
            return 0.0
    
    async def api_stability_test(self, num_requests: int = 20) -> Dict:
        """ÊµãËØïAPIÁ®≥ÂÆöÊÄßÂíåÂìçÂ∫îÊó∂Èó¥"""
        try:
            logger.info(f"üìä ÂºÄÂßãAPIÁ®≥ÂÆöÊÄßÊµãËØï: {num_requests}Ê¨°ËØ∑Ê±Ç")
            
            response_times = []
            success_count = 0
            error_count = 0
            
            for i in range(num_requests):
                start_time = time.time()
                try:
                    response = requests.get(f"{self.base_url}/api/data", timeout=10)
                    response_time = time.time() - start_time
                    
                    if response.status_code == 200:
                        data = response.json()
                        if data.get('success') and 'heatmap_data' in data.get('data', {}):
                            response_times.append(response_time)
                            success_count += 1
                        else:
                            error_count += 1
                    else:
                        error_count += 1
                        
                except Exception as e:
                    error_count += 1
                    logger.warning(f"ËØ∑Ê±Ç {i+1} Â§±Ë¥•: {e}")
                
                # ÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑËØ∑Ê±Ç
                await asyncio.sleep(0.1)
            
            if response_times:
                avg_response_time = statistics.mean(response_times)
                min_response_time = min(response_times)
                max_response_time = max(response_times)
                response_stability = statistics.stdev(response_times) if len(response_times) > 1 else 0.0
            else:
                avg_response_time = float('inf')
                min_response_time = float('inf')
                max_response_time = float('inf')
                response_stability = float('inf')
            
            success_rate = (success_count / num_requests) * 100
            
            return {
                'success': True,
                'total_requests': num_requests,
                'successful_requests': success_count,
                'failed_requests': error_count,
                'success_rate': success_rate,
                'avg_response_time': avg_response_time,
                'min_response_time': min_response_time,
                'max_response_time': max_response_time,
                'response_stability': response_stability,
                'api_stability': 'stable' if success_rate >= 95 and avg_response_time < 2.0 else 'unstable'
            }
            
        except Exception as e:
            logger.error(f"APIÁ®≥ÂÆöÊÄßÊµãËØïÂ§±Ë¥•: {e}")
            return {
                'success': False,
                'error': str(e),
                'api_stability': 'failed'
            }
    
    async def load_test(self, concurrent_requests: int = 10) -> Dict:
        """Ë¥üËΩΩÊµãËØï"""
        try:
            logger.info(f"üöÄ ÂºÄÂßãË¥üËΩΩÊµãËØï: {concurrent_requests}‰∏™Âπ∂ÂèëËØ∑Ê±Ç")
            
            start_time = time.time()
            
            async def make_request():
                try:
                    response = requests.get(f"{self.base_url}/api/data", timeout=5)
                    return response.status_code == 200 and response.json().get('success', False)
                except:
                    return False
            
            # Âπ∂ÂèëÊâßË°åËØ∑Ê±Ç
            with ThreadPoolExecutor(max_workers=concurrent_requests) as executor:
                loop = asyncio.get_event_loop()
                tasks = [
                    loop.run_in_executor(executor, lambda: requests.get(f"{self.base_url}/api/data", timeout=5))
                    for _ in range(concurrent_requests)
                ]
                results = await asyncio.gather(*tasks, return_exceptions=True)
            
            total_time = time.time() - start_time
            
            successful_responses = 0
            for result in results:
                if not isinstance(result, Exception):
                    try:
                        if result.status_code == 200 and result.json().get('success', False):
                            successful_responses += 1
                    except:
                        pass
            
            load_success_rate = (successful_responses / concurrent_requests) * 100
            throughput = concurrent_requests / total_time if total_time > 0 else 0
            
            return {
                'success': True,
                'concurrent_requests': concurrent_requests,
                'successful_responses': successful_responses,
                'total_time': total_time,
                'success_rate': load_success_rate,
                'throughput': throughput,  # ËØ∑Ê±Ç/Áßí
                'load_stability': 'stable' if load_success_rate >= 90 and throughput >= 5 else 'unstable'
            }
            
        except Exception as e:
            logger.error(f"Ë¥üËΩΩÊµãËØïÂ§±Ë¥•: {e}")
            return {
                'success': False,
                'error': str(e),
                'load_stability': 'failed'
            }
    
    def data_integrity_test(self) -> Dict:
        """Êï∞ÊçÆÂÆåÊï¥ÊÄßÊµãËØï"""
        try:
            logger.info("üîç ÂºÄÂßãÊï∞ÊçÆÂÆåÊï¥ÊÄßÊµãËØï")
            
            response = requests.get(f"{self.base_url}/api/data", timeout=10)
            if response.status_code != 200:
                return {
                    'success': False,
                    'error': 'Êó†Ê≥ïËé∑ÂèñAPIÂìçÂ∫î',
                    'data_integrity': 'failed'
                }
            
            data = response.json()
            
            # Ê£ÄÊü•Êï∞ÊçÆÁªìÊûÑÂÆåÊï¥ÊÄß
            required_fields = [
                'success', 'data', 'metadata', 'timestamp'
            ]
            
            data_fields = [
                'heatmap_data', 'tables', 'statistics', 'algorithm_settings'
            ]
            
            missing_fields = []
            for field in required_fields:
                if field not in data:
                    missing_fields.append(field)
            
            if 'data' in data:
                for field in data_fields:
                    if field not in data['data']:
                        missing_fields.append(f"data.{field}")
            
            # Ê£ÄÊü•ÁÉ≠ÂäõÂõæÁü©ÈòµÂÆåÊï¥ÊÄß
            heatmap_data = data.get('data', {}).get('heatmap_data', [])
            matrix_valid = True
            matrix_errors = []
            
            if not heatmap_data:
                matrix_valid = False
                matrix_errors.append("ÁÉ≠ÂäõÂõæÊï∞ÊçÆ‰∏∫Á©∫")
            else:
                expected_rows = 30
                expected_cols = 19
                
                if len(heatmap_data) != expected_rows:
                    matrix_valid = False
                    matrix_errors.append(f"Ë°åÊï∞ÈîôËØØ: ÊúüÊúõ{expected_rows}, ÂÆûÈôÖ{len(heatmap_data)}")
                
                for i, row in enumerate(heatmap_data):
                    if len(row) != expected_cols:
                        matrix_valid = False
                        matrix_errors.append(f"Á¨¨{i+1}Ë°åÂàóÊï∞ÈîôËØØ: ÊúüÊúõ{expected_cols}, ÂÆûÈôÖ{len(row)}")
                    
                    for j, cell in enumerate(row):
                        if not isinstance(cell, (int, float)):
                            matrix_valid = False
                            matrix_errors.append(f"ÂçïÂÖÉÊ†º[{i+1},{j+1}]Á±ªÂûãÈîôËØØ: {type(cell)}")
                        elif cell < 0 or cell > 1:
                            matrix_valid = False
                            matrix_errors.append(f"ÂçïÂÖÉÊ†º[{i+1},{j+1}]ÂÄºË∂ÖÂá∫ËåÉÂõ¥: {cell}")
            
            # Ê£ÄÊü•Ë°®Ê†ºÊï∞ÊçÆÂÆåÊï¥ÊÄß
            tables = data.get('data', {}).get('tables', [])
            tables_valid = True
            table_errors = []
            
            if len(tables) != 30:
                tables_valid = False
                table_errors.append(f"Ë°®Ê†ºÊï∞ÈáèÈîôËØØ: ÊúüÊúõ30, ÂÆûÈôÖ{len(tables)}")
            
            for i, table in enumerate(tables):
                required_table_fields = ['id', 'name', 'risk_level']
                for field in required_table_fields:
                    if field not in table:
                        tables_valid = False
                        table_errors.append(f"Ë°®Ê†º{i+1}Áº∫Â∞ëÂ≠óÊÆµ: {field}")
            
            return {
                'success': True,
                'missing_fields': missing_fields,
                'matrix_valid': matrix_valid,
                'matrix_errors': matrix_errors,
                'tables_valid': tables_valid,
                'table_errors': table_errors,
                'data_integrity': 'valid' if not missing_fields and matrix_valid and tables_valid else 'invalid'
            }
            
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂÆåÊï¥ÊÄßÊµãËØïÂ§±Ë¥•: {e}")
            return {
                'success': False,
                'error': str(e),
                'data_integrity': 'failed'
            }
    
    async def comprehensive_stability_test(self) -> Dict:
        """ÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØï"""
        try:
            logger.info("üéØ ÂºÄÂßãÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØï")
            
            test_results = {}
            
            # 1. Ëé∑ÂèñÊµãËØïÊï∞ÊçÆ
            response = requests.get(f"{self.base_url}/api/data", timeout=10)
            if response.status_code == 200:
                data = response.json()
                heatmap_data = data.get('data', {}).get('heatmap_data', [])
            else:
                heatmap_data = [[0.5 for _ in range(19)] for _ in range(30)]  # ÈªòËÆ§ÊµãËØïÊï∞ÊçÆ
            
            # 2. È´òÊñØÂπ≥ÊªëÊµãËØï
            gaussian_result = self.gaussian_smoothing_test(heatmap_data)
            test_results['gaussian_smoothing'] = gaussian_result
            
            # 3. APIÁ®≥ÂÆöÊÄßÊµãËØï
            api_result = await self.api_stability_test(15)
            test_results['api_stability'] = api_result
            
            # 4. Ë¥üËΩΩÊµãËØï
            load_result = await self.load_test(8)
            test_results['load_test'] = load_result
            
            # 5. Êï∞ÊçÆÂÆåÊï¥ÊÄßÊµãËØï
            integrity_result = self.data_integrity_test()
            test_results['data_integrity'] = integrity_result
            
            # ËÆ°ÁÆóÁªºÂêàÁ®≥ÂÆöÊÄßËØÑÂàÜ
            stability_score = self._calculate_stability_score(test_results)
            
            # ÁîüÊàêÁªºÂêàËØÑ‰º∞
            overall_status = self._get_overall_status(stability_score)
            
            return {
                'success': True,
                'test_results': test_results,
                'stability_score': stability_score,
                'overall_status': overall_status,
                'timestamp': datetime.now().isoformat(),
                'test_summary': self._generate_test_summary(test_results)
            }
            
        except Exception as e:
            logger.error(f"ÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØïÂ§±Ë¥•: {e}")
            return {
                'success': False,
                'error': str(e),
                'overall_status': 'failed'
            }
    
    def _calculate_stability_score(self, test_results: Dict) -> float:
        """ËÆ°ÁÆóÁ®≥ÂÆöÊÄßËØÑÂàÜ"""
        try:
            scores = []
            
            # È´òÊñØÂπ≥ÊªëËØÑÂàÜ (25%)
            gaussian = test_results.get('gaussian_smoothing', {})
            if gaussian.get('success') and gaussian.get('algorithm_stability') == 'stable':
                scores.append(100)
            elif gaussian.get('success'):
                scores.append(70)
            else:
                scores.append(0)
            
            # APIÁ®≥ÂÆöÊÄßËØÑÂàÜ (30%)
            api = test_results.get('api_stability', {})
            if api.get('success') and api.get('api_stability') == 'stable':
                success_rate = api.get('success_rate', 0)
                scores.append(min(100, success_rate))
            else:
                scores.append(0)
            
            # Ë¥üËΩΩÊµãËØïËØÑÂàÜ (25%)
            load = test_results.get('load_test', {})
            if load.get('success') and load.get('load_stability') == 'stable':
                load_success_rate = load.get('success_rate', 0)
                scores.append(min(100, load_success_rate))
            else:
                scores.append(0)
            
            # Êï∞ÊçÆÂÆåÊï¥ÊÄßËØÑÂàÜ (20%)
            integrity = test_results.get('data_integrity', {})
            if integrity.get('success') and integrity.get('data_integrity') == 'valid':
                scores.append(100)
            elif integrity.get('success'):
                scores.append(50)
            else:
                scores.append(0)
            
            # Âä†ÊùÉÂπ≥Âùá
            weights = [0.25, 0.30, 0.25, 0.20]
            weighted_score = sum(score * weight for score, weight in zip(scores, weights))
            
            return round(weighted_score, 1)
            
        except Exception:
            return 0.0
    
    def _get_overall_status(self, stability_score: float) -> str:
        """Ëé∑ÂèñÁªºÂêàÁä∂ÊÄÅËØÑ‰º∞"""
        if stability_score >= 95:
            return "üèÖ A+ (ÁÉ≠ÂäõÂõæÂÆåÁæéÁ®≥ÂÆö)"
        elif stability_score >= 90:
            return "‚úÖ A (ÁÉ≠ÂäõÂõæÁ®≥ÂÆöËøêË°å)"
        elif stability_score >= 80:
            return "üü¢ B+ (ÁÉ≠ÂäõÂõæËâØÂ•ΩÁ®≥ÂÆö)"
        elif stability_score >= 70:
            return "üü° B (ÁÉ≠ÂäõÂõæÂü∫Êú¨Á®≥ÂÆö)"
        elif stability_score >= 60:
            return "üü† C+ (ÁÉ≠ÂäõÂõæËΩªÂæÆ‰∏çÁ®≥ÂÆö)"
        else:
            return "üî¥ C (ÁÉ≠ÂäõÂõæ‰∏çÁ®≥ÂÆö)"
    
    def _generate_test_summary(self, test_results: Dict) -> Dict:
        """ÁîüÊàêÊµãËØïÊëòË¶Å"""
        summary = {
            'total_tests': len(test_results),
            'passed_tests': 0,
            'failed_tests': 0,
            'test_details': {}
        }
        
        for test_name, result in test_results.items():
            if result.get('success'):
                summary['passed_tests'] += 1
                summary['test_details'][test_name] = '‚úÖ ÈÄöËøá'
            else:
                summary['failed_tests'] += 1
                summary['test_details'][test_name] = '‚ùå Â§±Ë¥•'
        
        return summary


# ÂëΩ‰ª§Ë°åÊé•Âè£
async def main():
    """‰∏ªÂáΩÊï∞"""
    import argparse
    
    parser = argparse.ArgumentParser(description='ÁÉ≠ÂäõÂõæÁÆóÊ≥ïÁ®≥ÂÆöÊÄßÊµãËØïÂô®')
    parser.add_argument('--url', default='http://localhost:8089', help='ÁÉ≠ÂäõÂõæÊúçÂä°Âô®URL')
    parser.add_argument('--test-type', choices=['gaussian', 'api', 'load', 'integrity', 'comprehensive'], 
                       default='comprehensive', help='ÊµãËØïÁ±ªÂûã')
    parser.add_argument('--requests', type=int, default=20, help='APIÊµãËØïËØ∑Ê±ÇÊï∞')
    parser.add_argument('--concurrent', type=int, default=10, help='Ë¥üËΩΩÊµãËØïÂπ∂ÂèëÊï∞')
    
    args = parser.parse_args()
    
    tester = HeatmapStabilityTester(args.url)
    
    try:
        if args.test_type == 'comprehensive':
            print("üéØ ÂºÄÂßãÁÉ≠ÂäõÂõæÁÆóÊ≥ïÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØï...")
            result = await tester.comprehensive_stability_test()
            
            if result['success']:
                print(f"\n‚úÖ ÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØïÂÆåÊàê!")
                print(f"   Á®≥ÂÆöÊÄßËØÑÂàÜ: {result['stability_score']}/100")
                print(f"   ÁªºÂêàÁä∂ÊÄÅ: {result['overall_status']}")
                
                summary = result['test_summary']
                print(f"   ÊµãËØïÈÄöËøá: {summary['passed_tests']}/{summary['total_tests']}")
                
                for test_name, status in summary['test_details'].items():
                    print(f"     {test_name}: {status}")
                
                # ËØ¶ÁªÜÁªìÊûú
                print(f"\nüìä ËØ¶ÁªÜÊµãËØïÁªìÊûú:")
                for test_name, test_result in result['test_results'].items():
                    if test_result.get('success'):
                        if test_name == 'api_stability':
                            print(f"   APIÁ®≥ÂÆöÊÄß: ÊàêÂäüÁéá{test_result.get('success_rate', 0):.1f}%, Âπ≥ÂùáÂìçÂ∫î{test_result.get('avg_response_time', 0):.3f}Áßí")
                        elif test_name == 'load_test':
                            print(f"   Ë¥üËΩΩÊµãËØï: ÊàêÂäüÁéá{test_result.get('success_rate', 0):.1f}%, ÂêûÂêêÈáè{test_result.get('throughput', 0):.1f}ËØ∑Ê±Ç/Áßí")
                        elif test_name == 'gaussian_smoothing':
                            print(f"   È´òÊñØÂπ≥Êªë: Â§ÑÁêÜÊó∂Èó¥{test_result.get('processing_time', 0):.3f}Áßí, Áä∂ÊÄÅ{test_result.get('algorithm_stability', 'unknown')}")
                        elif test_name == 'data_integrity':
                            print(f"   Êï∞ÊçÆÂÆåÊï¥ÊÄß: {test_result.get('data_integrity', 'unknown')}")
            else:
                print(f"\n‚ùå ÁªºÂêàÁ®≥ÂÆöÊÄßÊµãËØïÂ§±Ë¥•: {result.get('error')}")
                
        print(f"\nüéâ ÁÉ≠ÂäõÂõæÁ®≥ÂÆöÊÄßÊµãËØïÂÆåÊàê!")
        
    except Exception as e:
        print(f"‚ùå ÊµãËØïÊâßË°åÂ§±Ë¥•: {e}")


if __name__ == "__main__":
    asyncio.run(main())
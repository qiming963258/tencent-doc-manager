# 功能模块化 - 代码实现示例

## 模块1：智能文档下载器 - 独立封装示例

```python
# smart_doc_downloader.py
"""
智能文档下载器 - 可复用模块
支持腾讯文档、飞书文档等多平台
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Optional
import asyncio
from datetime import datetime
from pathlib import Path

class DocumentDownloader(ABC):
    """文档下载器基类"""

    @abstractmethod
    async def download(self, url: str, format: str = 'csv') -> str:
        """下载单个文档"""
        pass

    @abstractmethod
    def authenticate(self, credentials: Dict) -> bool:
        """认证"""
        pass

class TencentDocDownloader(DocumentDownloader):
    """腾讯文档下载器"""

    def __init__(self):
        self.exporter = None
        self.cookie_manager = CookieManager()

    async def download(self, url: str, format: str = 'csv') -> str:
        """
        应用场景：
        1. 海龙国际：下载客户共享的订单表
        2. 通用场景：任何腾讯文档自动化下载
        """
        # 利用现有的 TencentDocAutoExporter
        from production.core_modules.tencent_export_automation import TencentDocAutoExporter

        if not self.exporter:
            self.exporter = TencentDocAutoExporter()

        result = await self.exporter.export_document(
            url=url,
            cookies=self.cookie_manager.get_valid_cookie(),
            export_format=format,
            download_dir=self._get_archive_path()
        )

        # 版本归档
        self._archive_version(result['file_path'])
        return result['file_path']

    def _get_archive_path(self) -> Path:
        """按周归档路径"""
        week = datetime.now().isocalendar()[1]
        year = datetime.now().year
        return Path(f"archives/{year}_W{week:02d}")

    def _archive_version(self, file_path: str):
        """版本管理 - 适合海龙国际的报关单据归档"""
        # 按航次/船期/客户等维度归档
        pass

class BatchDownloadManager:
    """批量下载管理器 - 适合海龙国际的批量单据处理"""

    def __init__(self, downloader: DocumentDownloader):
        self.downloader = downloader
        self.results = []

    async def batch_download(self, urls: List[Dict]) -> List[Dict]:
        """
        批量下载 - 并发处理提高效率

        应用场景：
        - 每日批量下载所有客户订单
        - 定时拉取供应商报价单
        """
        tasks = []
        for item in urls:
            task = self.download_with_metadata(item)
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)
        return self._process_results(results)

    async def download_with_metadata(self, item: Dict) -> Dict:
        """带元数据的下载 - 记录来源、时间、类型等"""
        try:
            file_path = await self.downloader.download(
                item['url'],
                item.get('format', 'csv')
            )
            return {
                'success': True,
                'file_path': file_path,
                'metadata': {
                    'source': item.get('source', 'unknown'),
                    'type': item.get('type', 'general'),
                    'customer': item.get('customer'),
                    'timestamp': datetime.now().isoformat()
                }
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'url': item['url']
            }

# 使用示例 - 海龙国际场景
async def hailong_daily_download():
    """海龙国际每日文档下载任务"""

    # 初始化下载器
    downloader = TencentDocDownloader()
    batch_manager = BatchDownloadManager(downloader)

    # 配置下载任务
    daily_docs = [
        {
            'url': 'https://docs.qq.com/sheet/xxx',
            'type': '报关单据',
            'customer': '深圳A客户',
            'format': 'xlsx'
        },
        {
            'url': 'https://docs.qq.com/sheet/yyy',
            'type': '订舱单',
            'customer': '上海B客户',
            'format': 'csv'
        }
    ]

    # 执行批量下载
    results = await batch_manager.batch_download(daily_docs)

    # 触发后续流程
    for result in results:
        if result['success']:
            # 触发报关流程
            if result['metadata']['type'] == '报关单据':
                trigger_customs_declaration(result['file_path'])
            # 触发订舱流程
            elif result['metadata']['type'] == '订舱单':
                trigger_booking_process(result['file_path'])
```

---

## 模块2：智能对比引擎 - 物流行业定制版

```python
# logistics_diff_analyzer.py
"""
物流行业专用对比分析引擎
支持运价表、报关要素、提单等专业文档对比
"""
from typing import List, Dict, Tuple
import pandas as pd
from enum import Enum

class DocumentType(Enum):
    """物流文档类型"""
    FREIGHT_RATE = "运价表"
    CUSTOMS_DECLARATION = "报关单"
    BILL_OF_LADING = "提单"
    BOOKING_FORM = "订舱单"
    INVOICE = "商业发票"

class LogisticsDiffAnalyzer:
    """物流行业对比分析器"""

    def __init__(self):
        # 复用现有对比器
        from production.core_modules.production_csv_comparator import ProductionCSVComparator
        self.base_comparator = ProductionCSVComparator()
        self.ai_analyzer = SemanticAnalyzer()

    def analyze_freight_rate_change(self,
                                   old_rate: pd.DataFrame,
                                   new_rate: pd.DataFrame) -> Dict:
        """
        运价表对比分析 - 海龙国际核心需求

        功能：
        1. 识别涨价/降价航线
        2. 计算涨幅百分比
        3. 生成客户通知建议
        """
        results = {
            'increased_routes': [],
            'decreased_routes': [],
            'new_routes': [],
            'removed_routes': [],
            'customer_impact': []
        }

        # 航线匹配
        for route in new_rate['route'].unique():
            old_price = old_rate[old_rate['route'] == route]['price'].mean()
            new_price = new_rate[new_rate['route'] == route]['price'].mean()

            if pd.isna(old_price):
                results['new_routes'].append({
                    'route': route,
                    'price': new_price,
                    'suggestion': f"新增航线{route}，建议推广给有需求的客户"
                })
            elif new_price > old_price:
                change_pct = (new_price - old_price) / old_price * 100
                results['increased_routes'].append({
                    'route': route,
                    'old_price': old_price,
                    'new_price': new_price,
                    'change_pct': change_pct,
                    'action': self._suggest_action(change_pct)
                })

        return results

    def _suggest_action(self, change_pct: float) -> str:
        """基于涨幅生成行动建议"""
        if change_pct < 5:
            return "小幅调整，可暂不通知客户"
        elif change_pct < 10:
            return "中等涨幅，建议邮件通知大客户"
        else:
            return "大幅涨价，需紧急通知所有客户并提供替代方案"

    def validate_customs_declaration(self,
                                    declaration: pd.DataFrame,
                                    template: pd.DataFrame) -> Dict:
        """
        报关单合规性检查 - 避免海关罚款

        功能：
        1. 必填项检查
        2. HS编码验证
        3. 数值合理性检查
        """
        issues = []

        # 必填项检查
        required_fields = ['HS_CODE', 'GOODS_NAME', 'QUANTITY', 'VALUE']
        for field in required_fields:
            if field in declaration.columns:
                missing = declaration[declaration[field].isna()]
                if not missing.empty:
                    issues.append({
                        'type': 'MISSING_REQUIRED',
                        'field': field,
                        'rows': missing.index.tolist(),
                        'severity': 'HIGH',
                        'risk': '可能导致报关延误或退单'
                    })

        # HS编码格式验证
        if 'HS_CODE' in declaration.columns:
            invalid_hs = declaration[
                ~declaration['HS_CODE'].str.match(r'^\d{10}$', na=False)
            ]
            if not invalid_hs.empty:
                issues.append({
                    'type': 'INVALID_HS_CODE',
                    'rows': invalid_hs.index.tolist(),
                    'severity': 'HIGH',
                    'suggestion': '请核对HS编码是否为10位数字'
                })

        return {
            'is_valid': len(issues) == 0,
            'issues': issues,
            'risk_level': self._calculate_risk_level(issues)
        }

    def _calculate_risk_level(self, issues: List[Dict]) -> str:
        """计算整体风险等级"""
        high_count = sum(1 for i in issues if i['severity'] == 'HIGH')
        if high_count > 3:
            return "极高风险 - 不建议申报"
        elif high_count > 0:
            return "高风险 - 需修正后申报"
        else:
            return "低风险 - 可以申报"

class MultilingualBOLComparator:
    """多语言提单对比器 - 解决国际贸易语言障碍"""

    def compare_chinese_english_bol(self,
                                   cn_bol: Dict,
                                   en_bol: Dict) -> Dict:
        """
        中英文提单对比 - 确保翻译准确性

        应用价值：
        - 避免因翻译错误导致的货物滞留
        - 确保收货人信息一致
        - 验证货物描述准确性
        """
        from production.servers.claude_processor_8081 import process_with_claude

        # 关键字段映射
        field_mapping = {
            '收货人': 'Consignee',
            '发货人': 'Shipper',
            '货物描述': 'Description of Goods',
            '毛重': 'Gross Weight',
            '体积': 'Volume'
        }

        discrepancies = []

        for cn_field, en_field in field_mapping.items():
            cn_value = cn_bol.get(cn_field, '')
            en_value = en_bol.get(en_field, '')

            # AI语义对比
            is_match = process_with_claude(
                f"对比这两个值是否语义相同：\n中文：{cn_value}\n英文：{en_value}"
            )

            if not is_match:
                discrepancies.append({
                    'field': cn_field,
                    'cn_value': cn_value,
                    'en_value': en_value,
                    'risk': '可能导致清关问题'
                })

        return {
            'is_consistent': len(discrepancies) == 0,
            'discrepancies': discrepancies
        }
```

---

## 模块3：智能可视化引擎 - 物流大屏定制

```python
# logistics_visualization.py
"""
物流行业可视化引擎
实时监控全球供应链状态
"""
import numpy as np
from typing import List, Dict, Tuple

class LogisticsHeatmapEngine:
    """物流热力图引擎"""

    def __init__(self):
        # 复用现有热力图逻辑
        from production.servers.final_heatmap_server import apply_gaussian_smooth
        self.gaussian_smooth = apply_gaussian_smooth

    def generate_route_capacity_heatmap(self,
                                       route_data: Dict) -> np.ndarray:
        """
        生成航线运力热力图

        可视化维度：
        - X轴：出发港口
        - Y轴：目的港口
        - 颜色：运力饱和度（绿→黄→红）
        """
        ports = list(set(route_data.keys()))
        matrix = np.zeros((len(ports), len(ports)))

        for i, origin in enumerate(ports):
            for j, dest in enumerate(ports):
                key = f"{origin}-{dest}"
                if key in route_data:
                    # 运力饱和度 0-100
                    capacity = route_data[key].get('capacity_usage', 0)
                    matrix[i][j] = capacity

        # 应用高斯平滑识别热点区域
        smoothed = self.gaussian_smooth(matrix)

        return self._apply_risk_colors(smoothed)

    def _apply_risk_colors(self, matrix: np.ndarray) -> Dict:
        """应用风险配色方案"""
        return {
            'matrix': matrix.tolist(),
            'color_scheme': {
                'low': '#00FF00',      # 绿色：运力充足
                'medium': '#FFFF00',   # 黄色：运力紧张
                'high': '#FF0000',     # 红色：运力饱和
                'critical': '#8B0000'  # 深红：需紧急调配
            },
            'thresholds': {
                'low': 40,
                'medium': 70,
                'high': 85,
                'critical': 95
            }
        }

    def generate_warehouse_3d_heatmap(self,
                                     warehouse_data: List[Dict]) -> Dict:
        """
        3D仓库热力图 - 创新应用

        维度：
        - X/Y：仓库平面位置
        - Z：货架层高
        - 颜色：货物周转率
        """
        # 这是一个高级功能示例
        pass

class RealTimeLogisticsDashboard:
    """实时物流监控大屏"""

    def __init__(self):
        self.heatmap_engine = LogisticsHeatmapEngine()
        self.websocket_server = None

    def start_monitoring(self):
        """
        启动实时监控

        监控内容：
        1. 全球港口拥堵状况
        2. 主要航线运价波动
        3. 仓库库存分布
        4. 客户订单状态
        """
        import asyncio
        from production.servers.final_heatmap_server import app

        # 复用现有的WebSocket架构
        @app.route('/api/logistics-realtime')
        async def logistics_updates():
            while True:
                data = {
                    'port_congestion': self._get_port_status(),
                    'freight_rates': self._get_rate_changes(),
                    'warehouse_status': self._get_warehouse_data(),
                    'order_tracking': self._get_order_status()
                }

                # 推送到前端
                await self.broadcast_update(data)
                await asyncio.sleep(30)  # 30秒更新一次

    def _get_port_status(self) -> Dict:
        """获取港口实时状态"""
        # 对接港口API或爬虫数据
        return {
            'shanghai': {'congestion': 85, 'wait_time': '48h'},
            'singapore': {'congestion': 45, 'wait_time': '12h'},
            'rotterdam': {'congestion': 60, 'wait_time': '24h'}
        }
```

---

## 模块4：AI文档处理器 - 报关自动化

```python
# customs_ai_processor.py
"""
AI驱动的报关文档自动化处理
减少90%人工处理时间
"""
from typing import Dict, List, Optional
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import PatternFill

class CustomsDocumentAI:
    """报关文档AI处理器"""

    def __init__(self):
        # 复用现有的Excel处理能力
        from production.core_modules.intelligent_excel_marker_v3 import mark_excel_with_risks
        self.excel_marker = mark_excel_with_risks

    def auto_fill_customs_form(self,
                              order_data: pd.DataFrame) -> Workbook:
        """
        AI自动填写报关单

        功能亮点：
        1. 自动识别商品类别
        2. 智能匹配HS编码
        3. 自动计算税费
        4. 合规性预检
        """
        wb = Workbook()
        ws = wb.active

        for idx, row in order_data.iterrows():
            # AI识别商品类别
            category = self._identify_product_category(row['product_name'])

            # 智能匹配HS编码
            hs_code = self._match_hs_code(category, row['product_desc'])

            # 填充报关单
            ws.append([
                row['order_no'],
                row['product_name'],
                hs_code,
                row['quantity'],
                row['unit_price'],
                self._calculate_customs_value(row),
                self._predict_duty_rate(hs_code)
            ])

            # 风险标记
            if self._is_sensitive_goods(category):
                ws[f'A{idx+2}'].fill = PatternFill(
                    start_color="FFFF00",
                    fill_type="solid"
                )
                ws[f'A{idx+2}'].comment = "敏感货物，需要额外许可证"

        return wb

    def _identify_product_category(self, product_name: str) -> str:
        """AI商品分类"""
        from production.servers.claude_processor_8081 import process_with_claude

        prompt = f"""
        商品名称：{product_name}
        请识别该商品的海关分类（如：电子产品、纺织品、机械设备等）
        """

        return process_with_claude(prompt)

    def _match_hs_code(self, category: str, description: str) -> str:
        """智能HS编码匹配"""
        # 这里可以接入海关HS编码数据库
        hs_database = {
            '电子产品': '8517120000',
            '纺织品': '5209110000',
            '机械设备': '8428909090'
        }
        return hs_database.get(category, '9999999999')

    def generate_multilingual_invoice(self,
                                     order: Dict,
                                     languages: List[str]) -> Dict[str, Workbook]:
        """
        多语言商业发票生成

        应用场景：
        - 一键生成中、英、日、韩版本发票
        - 自动换算多币种
        - 符合各国格式要求
        """
        invoices = {}

        for lang in languages:
            wb = Workbook()
            ws = wb.active

            # 翻译表头
            headers = self._translate_headers(lang)
            ws.append(headers)

            # 翻译并填充内容
            for item in order['items']:
                translated_item = self._translate_item(item, lang)
                ws.append(translated_item)

            # 添加合规条款
            self._add_compliance_terms(ws, lang, order['destination'])

            invoices[lang] = wb

        return invoices

    def intelligent_document_audit(self,
                                  document_path: str) -> Dict:
        """
        智能单据审核

        审核内容：
        1. 数据完整性
        2. 逻辑一致性
        3. 合规性检查
        4. 异常检测
        """
        df = pd.read_excel(document_path)

        audit_results = {
            'completeness': self._check_completeness(df),
            'consistency': self._check_consistency(df),
            'compliance': self._check_compliance(df),
            'anomalies': self._detect_anomalies(df),
            'risk_score': 0
        }

        # 计算综合风险分数
        audit_results['risk_score'] = self._calculate_risk_score(audit_results)

        # 生成审核报告
        if audit_results['risk_score'] > 70:
            audit_results['recommendation'] = "高风险，建议人工复核"
        elif audit_results['risk_score'] > 30:
            audit_results['recommendation'] = "中风险，需要修正部分内容"
        else:
            audit_results['recommendation'] = "低风险，可以直接提交"

        return audit_results
```

---

## 快速集成指南

### 1. 安装依赖
```bash
pip install pandas openpyxl aiohttp asyncio
```

### 2. 导入模块
```python
from modules.smart_doc_downloader import TencentDocDownloader
from modules.logistics_diff_analyzer import LogisticsDiffAnalyzer
from modules.logistics_visualization import LogisticsHeatmapEngine
from modules.customs_ai_processor import CustomsDocumentAI
```

### 3. 初始化使用
```python
# 文档下载
downloader = TencentDocDownloader()
file = await downloader.download('https://docs.qq.com/sheet/xxx')

# 对比分析
analyzer = LogisticsDiffAnalyzer()
changes = analyzer.analyze_freight_rate_change(old_df, new_df)

# 可视化
visualizer = LogisticsHeatmapEngine()
heatmap = visualizer.generate_route_capacity_heatmap(route_data)

# AI处理
ai_processor = CustomsDocumentAI()
customs_form = ai_processor.auto_fill_customs_form(order_df)
```

---

## 性能优化建议

1. **并发处理**: 使用asyncio提高下载和处理速度
2. **缓存机制**: Redis缓存频繁访问的数据
3. **批量操作**: 减少API调用次数
4. **增量更新**: 只处理变更部分，不全量刷新

---

这些模块化的代码示例展示了如何将现有系统拆分成独立、可复用的组件，每个组件都能为海龙国际的不同业务场景创造价值。
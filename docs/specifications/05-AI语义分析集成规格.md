# AI语义分析集成规格书

## 1. AI集成总体架构

### 1.1 Claude Sonnet API集成设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    AI语义分析集成架构                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  L2修改检测层                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ 修改识别器       │  │ 风险分级器       │  │ 语义候选筛选    │              │
│  │ - 字段变更检测   │  │ - L1/L2/L3分级   │  │ - L2修改提取    │              │
│  │ - 变更量化       │  │ - 自动分流       │  │ - 上下文收集    │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────────────────────────┤
│  AI分析服务层                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ 提示词引擎       │  │ Claude API调用   │  │ 结果解析器       │              │
│  │ - 业务场景模板   │  │ - 异步批处理     │  │ - 结构化输出     │              │
│  │ - 上下文注入     │  │ - 重试机制       │  │ - 置信度评估     │              │
│  │ - 参数优化       │  │ - 限流控制       │  │ - 错误处理       │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────────────────────────┤
│  缓存和优化层                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ Redis智能缓存    │  │ 结果聚合器       │  │ 性能监控        │              │
│  │ - 语义哈希缓存   │  │ - 批量结果合并   │  │ - API调用统计    │              │
│  │ - 24小时TTL     │  │ - 置信度加权     │  │ - 错误率监控     │              │
│  │ - 热点数据预热   │  │ - 一致性检查     │  │ - 响应时间分析   │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 核心设计原则

1. **精准定向**: 只对L2级别修改进行AI分析，避免资源浪费
2. **业务导向**: 基于具体业务场景设计专业提示词
3. **高可用性**: 实现降级方案和错误恢复机制  
4. **性能优化**: 智能缓存和批量处理提升效率
5. **成本控制**: API调用优化和重复分析避免

## 2. Claude API集成实现

### 2.1 API客户端设计

```python
# Claude Sonnet API集成客户端
class ClaudeSemanticAnalysisClient:
    """Claude语义分析API客户端"""
    
    def __init__(self, api_key, base_url="https://api.anthropic.com"):
        self.api_key = api_key
        self.base_url = base_url
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=60),
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
                "Anthropic-Version": "2023-06-01"
            }
        )
        
        # API调用统计
        self.api_stats = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "cache_hits": 0,
            "average_response_time": 0
        }
        
        # 重试配置
        self.retry_config = {
            "max_retries": 3,
            "base_delay": 1.0,
            "max_delay": 10.0,
            "backoff_factor": 2.0
        }
    
    async def analyze_modification_batch(self, modifications, batch_size=5):
        """批量分析修改项"""
        results = []
        
        # 分批处理以避免API限流
        for i in range(0, len(modifications), batch_size):
            batch = modifications[i:i + batch_size]
            
            # 并发处理当前批次
            batch_tasks = [
                self._analyze_single_modification(mod) for mod in batch
            ]
            
            batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
            
            # 处理批次结果
            for mod, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    # 处理异常情况
                    results.append({
                        "modification_id": mod["id"],
                        "status": "error",
                        "error": str(result),
                        "fallback_analysis": self._fallback_rule_analysis(mod)
                    })
                else:
                    results.append(result)
            
            # 批次间延迟以遵守API限流
            if i + batch_size < len(modifications):
                await asyncio.sleep(0.5)
        
        return results
    
    async def _analyze_single_modification(self, modification):
        """分析单个修改项"""
        
        # 生成缓存键
        cache_key = self._generate_cache_key(modification)
        
        # 检查缓存
        cached_result = await self._get_cached_result(cache_key)
        if cached_result:
            self.api_stats["cache_hits"] += 1
            return cached_result
        
        # 构建分析提示词
        analysis_prompt = self._build_analysis_prompt(modification)
        
        # 调用Claude API
        try:
            start_time = time.time()
            
            response = await self._call_claude_api({
                "model": "claude-3-sonnet-20240229",
                "max_tokens": 500,
                "temperature": 0.1,  # 低温度确保分析一致性
                "messages": [
                    {
                        "role": "user",
                        "content": analysis_prompt
                    }
                ]
            })
            
            end_time = time.time()
            response_time = end_time - start_time
            
            # 解析响应
            analysis_result = self._parse_claude_response(
                response, modification, response_time
            )
            
            # 缓存结果
            await self._cache_result(cache_key, analysis_result, ttl=86400)  # 24小时
            
            # 更新统计
            self._update_api_stats(True, response_time)
            
            return analysis_result
            
        except Exception as e:
            self._update_api_stats(False, 0)
            
            # 降级处理
            return {
                "modification_id": modification["id"],
                "status": "fallback",
                "api_error": str(e),
                "fallback_analysis": self._fallback_rule_analysis(modification)
            }
    
    async def _call_claude_api(self, payload):
        """调用Claude API（带重试机制）"""
        
        for attempt in range(self.retry_config["max_retries"] + 1):
            try:
                async with self.session.post(
                    f"{self.base_url}/v1/messages",
                    json=payload
                ) as response:
                    
                    if response.status == 200:
                        result = await response.json()
                        self.api_stats["total_requests"] += 1
                        return result
                    elif response.status == 429:  # 速率限制
                        if attempt < self.retry_config["max_retries"]:
                            delay = min(
                                self.retry_config["base_delay"] * 
                                (self.retry_config["backoff_factor"] ** attempt),
                                self.retry_config["max_delay"]
                            )
                            await asyncio.sleep(delay)
                            continue
                    else:
                        error_text = await response.text()
                        raise ClaudeAPIError(f"HTTP {response.status}: {error_text}")
                        
            except asyncio.TimeoutError:
                if attempt < self.retry_config["max_retries"]:
                    await asyncio.sleep(2 ** attempt)
                    continue
                raise ClaudeAPIError("API调用超时")
            
            except Exception as e:
                if attempt < self.retry_config["max_retries"]:
                    await asyncio.sleep(1)
                    continue
                raise ClaudeAPIError(f"API调用失败: {str(e)}")
        
        raise ClaudeAPIError("API调用重试次数超限")
```

### 2.2 专业提示词引擎

```python
class BusinessPromptEngine:
    """业务场景专用提示词引擎"""
    
    def __init__(self):
        self.base_prompt_template = """
        你是一个专业的企业文档变更分析专家。请分析以下腾讯文档表格的字段修改，判断其合理性和风险等级。
        
        ## 业务背景
        这是一个企业级项目管理表格，用于追踪项目进度和人员安排。该字段属于L2级别（需要语义审核），不是绝对禁止修改的L1字段，也不是可自由编辑的L3字段。
        
        ## 分析要求
        请从以下维度进行分析：
        1. **业务合理性**: 这个修改在业务逻辑上是否合理
        2. **影响范围**: 修改可能影响的其他字段或流程  
        3. **风险评估**: 修改可能带来的风险
        4. **建议操作**: 应该批准、拒绝还是需要进一步审核
        
        ## 修改详情
        表格名称: {table_name}
        字段名称: {column_name}
        原始值: {original_value}
        修改值: {new_value}
        修改时间: {modification_time}
        修改人: {modifier}
        变更背景: {change_context}
        
        ## 业务规则参考
        {business_rules}
        
        请以JSON格式返回分析结果：
        {{
            "recommendation": "APPROVE|REJECT|REVIEW",
            "confidence": 0.0-1.0,
            "reasoning": "详细分析理由",
            "business_impact": "HIGH|MEDIUM|LOW",
            "suggested_action": "具体建议操作",
            "risk_factors": ["识别的风险因素"],
            "approval_conditions": ["批准所需条件"]
        }}
        """
        
        # 不同列类型的专用规则
        self.column_specific_rules = {
            "负责人": {
                "business_context": "人员调配通常涉及权限和责任转移",
                "approval_criteria": [
                    "新负责人具备相应技能和权限",
                    "原负责人确认交接",
                    "项目经理批准人员变更"
                ],
                "risk_factors": [
                    "知识传承中断",
                    "进度延误风险",
                    "质量控制变化"
                ]
            },
            "具体计划内容": {
                "business_context": "计划内容变更可能影响项目范围和资源分配", 
                "approval_criteria": [
                    "变更符合项目目标",
                    "资源需求在可承受范围",
                    "时间线调整合理"
                ],
                "risk_factors": [
                    "范围蔓延",
                    "资源冲突",
                    "交付延期"
                ]
            },
            "协助人": {
                "business_context": "协助人变更影响团队协作和工作分配",
                "approval_criteria": [
                    "新协助人有相关技能",
                    "工作负荷平衡",
                    "团队协作顺畅"
                ],
                "risk_factors": [
                    "协作效率下降",
                    "沟通成本增加",
                    "技能不匹配"
                ]
            }
            # ... 其他列的规则
        }
    
    def build_analysis_prompt(self, modification):
        """构建分析提示词"""
        column_name = modification["column_name"]
        
        # 获取列特定的业务规则
        column_rules = self.column_specific_rules.get(column_name, {
            "business_context": "通用业务字段修改",
            "approval_criteria": ["符合业务逻辑", "无明显风险"],
            "risk_factors": ["数据一致性", "流程影响"]
        })
        
        # 构建业务规则文本
        business_rules_text = self._format_business_rules(column_rules)
        
        # 填充提示词模板
        prompt = self.base_prompt_template.format(
            table_name=modification.get("table_name", "未知表格"),
            column_name=column_name,
            original_value=modification.get("original_value", "未知"),
            new_value=modification.get("new_value", "未知"),
            modification_time=modification.get("modification_time", "未知"),
            modifier=modification.get("modifier", "未知"),
            change_context=modification.get("change_context", "无额外上下文"),
            business_rules=business_rules_text
        )
        
        return prompt
    
    def _format_business_rules(self, column_rules):
        """格式化业务规则文本"""
        rules_text = f"""
        **业务背景**: {column_rules['business_context']}
        
        **批准标准**:
        {chr(10).join([f"- {criteria}" for criteria in column_rules['approval_criteria']])}
        
        **风险因素**:
        {chr(10).join([f"- {risk}" for risk in column_rules['risk_factors']])}
        """
        
        return rules_text.strip()
```

### 2.3 结果解析和验证

```python
class AnalysisResultProcessor:
    """AI分析结果处理器"""
    
    def __init__(self):
        self.result_schema = {
            "recommendation": {"type": str, "choices": ["APPROVE", "REJECT", "REVIEW"]},
            "confidence": {"type": float, "range": [0.0, 1.0]},
            "reasoning": {"type": str, "min_length": 10},
            "business_impact": {"type": str, "choices": ["HIGH", "MEDIUM", "LOW"]},
            "suggested_action": {"type": str, "min_length": 5},
            "risk_factors": {"type": list, "item_type": str},
            "approval_conditions": {"type": list, "item_type": str}
        }
    
    def parse_claude_response(self, raw_response, modification_context):
        """解析Claude API响应"""
        try:
            # 提取消息内容
            content = raw_response["content"][0]["text"]
            
            # 尝试提取JSON部分
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start == -1 or json_end == 0:
                raise ValueError("响应中未找到JSON格式数据")
            
            json_content = content[json_start:json_end]
            parsed_result = json.loads(json_content)
            
            # 验证结果格式
            validated_result = self._validate_analysis_result(parsed_result)
            
            # 增强结果信息
            enhanced_result = self._enhance_analysis_result(
                validated_result, modification_context
            )
            
            return enhanced_result
            
        except Exception as e:
            # 解析失败时返回安全默认值
            return {
                "recommendation": "REVIEW",
                "confidence": 0.0,
                "reasoning": f"AI分析解析失败: {str(e)}",
                "business_impact": "MEDIUM",
                "suggested_action": "需要人工审核",
                "risk_factors": ["AI分析不可用"],
                "approval_conditions": ["人工审核确认"],
                "parse_error": str(e),
                "raw_response": raw_response
            }
    
    def _validate_analysis_result(self, result):
        """验证分析结果格式"""
        validated = {}
        
        for field, schema in self.result_schema.items():
            value = result.get(field)
            
            if value is None:
                # 提供默认值
                validated[field] = self._get_default_value(field, schema)
                continue
            
            # 类型验证
            if not isinstance(value, schema["type"]):
                try:
                    value = schema["type"](value)
                except:
                    validated[field] = self._get_default_value(field, schema)
                    continue
            
            # 范围验证
            if "choices" in schema and value not in schema["choices"]:
                validated[field] = schema["choices"][0]  # 默认第一个选项
            elif "range" in schema:
                value = max(schema["range"][0], min(schema["range"][1], value))
                validated[field] = value
            elif "min_length" in schema and len(str(value)) < schema["min_length"]:
                validated[field] = self._get_default_value(field, schema)
            else:
                validated[field] = value
        
        return validated
    
    def _enhance_analysis_result(self, result, context):
        """增强分析结果"""
        enhanced = result.copy()
        
        # 添加元数据
        enhanced.update({
            "modification_id": context["id"],
            "analysis_timestamp": datetime.now().isoformat(),
            "ai_model": "claude-3-sonnet",
            "processing_version": "1.0"
        })
        
        # 计算综合风险评分
        risk_score = self._calculate_risk_score(result)
        enhanced["risk_score"] = risk_score
        
        # 生成执行建议
        execution_plan = self._generate_execution_plan(result, context)
        enhanced["execution_plan"] = execution_plan
        
        return enhanced
    
    def _calculate_risk_score(self, result):
        """计算综合风险评分"""
        base_score = {
            "LOW": 0.2,
            "MEDIUM": 0.5, 
            "HIGH": 0.8
        }.get(result["business_impact"], 0.5)
        
        confidence_factor = result["confidence"]
        risk_factor_count = len(result.get("risk_factors", []))
        
        # 综合计算
        risk_score = base_score * (1 - confidence_factor * 0.3) + risk_factor_count * 0.1
        
        return min(1.0, max(0.0, risk_score))
```

## 3. 智能缓存系统

### 3.1 语义哈希缓存

```python
class SemanticCacheManager:
    """语义哈希缓存管理器"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_prefix = "ai_analysis"
        self.default_ttl = 86400  # 24小时
        
    def generate_semantic_hash(self, modification):
        """生成语义哈希键"""
        # 提取核心语义特征
        semantic_features = {
            "column_name": modification["column_name"],
            "change_type": self._classify_change_type(
                modification["original_value"], 
                modification["new_value"]
            ),
            "value_similarity": self._calculate_value_similarity(
                modification["original_value"],
                modification["new_value"]
            ),
            "context_hash": self._hash_context(modification.get("change_context", ""))
        }
        
        # 生成稳定的哈希
        feature_string = "|".join([
            str(semantic_features["column_name"]),
            str(semantic_features["change_type"]), 
            f"{semantic_features['value_similarity']:.2f}",
            str(semantic_features["context_hash"])
        ])
        
        return hashlib.md5(feature_string.encode()).hexdigest()
    
    async def get_cached_analysis(self, cache_key):
        """获取缓存的分析结果"""
        try:
            cached_data = await self.redis.get(f"{self.cache_prefix}:{cache_key}")
            if cached_data:
                return json.loads(cached_data)
        except Exception as e:
            logger.warning(f"缓存读取失败: {e}")
        return None
    
    async def cache_analysis_result(self, cache_key, result, ttl=None):
        """缓存分析结果"""
        try:
            ttl = ttl or self.default_ttl
            serialized = json.dumps(result, ensure_ascii=False)
            await self.redis.setex(
                f"{self.cache_prefix}:{cache_key}",
                ttl,
                serialized
            )
            
            # 更新缓存统计
            await self._update_cache_stats(cache_key, "write")
            
        except Exception as e:
            logger.error(f"缓存写入失败: {e}")
    
    def _classify_change_type(self, original, new):
        """分类变更类型"""
        if not original and new:
            return "addition"
        elif original and not new:
            return "deletion"
        elif str(original).lower() == str(new).lower():
            return "case_change"
        elif self._is_typo_correction(original, new):
            return "typo_correction"
        elif self._is_format_change(original, new):
            return "format_change"
        else:
            return "content_change"
```

## 4. 性能监控和优化

### 4.1 AI服务性能监控

```python
class AIServiceMonitor:
    """AI服务性能监控器"""
    
    def __init__(self):
        self.metrics = {
            "api_calls_total": 0,
            "api_calls_successful": 0,
            "api_calls_failed": 0,
            "cache_hit_rate": 0.0,
            "average_response_time": 0.0,
            "cost_estimation": 0.0
        }
        
        self.performance_targets = {
            "max_response_time": 5.0,  # 5秒
            "min_success_rate": 0.95,  # 95%
            "max_cost_per_analysis": 0.01  # $0.01
        }
    
    def record_api_call(self, success, response_time, cost=0.0):
        """记录API调用指标"""
        self.metrics["api_calls_total"] += 1
        
        if success:
            self.metrics["api_calls_successful"] += 1
        else:
            self.metrics["api_calls_failed"] += 1
        
        # 更新平均响应时间
        total_calls = self.metrics["api_calls_total"]
        current_avg = self.metrics["average_response_time"]
        self.metrics["average_response_time"] = (
            (current_avg * (total_calls - 1) + response_time) / total_calls
        )
        
        self.metrics["cost_estimation"] += cost
    
    def generate_performance_report(self):
        """生成性能报告"""
        success_rate = (
            self.metrics["api_calls_successful"] / self.metrics["api_calls_total"]
            if self.metrics["api_calls_total"] > 0 else 0
        )
        
        avg_cost = (
            self.metrics["cost_estimation"] / self.metrics["api_calls_total"]
            if self.metrics["api_calls_total"] > 0 else 0
        )
        
        performance_status = {
            "response_time": "GOOD" if self.metrics["average_response_time"] <= self.performance_targets["max_response_time"] else "POOR",
            "success_rate": "GOOD" if success_rate >= self.performance_targets["min_success_rate"] else "POOR", 
            "cost_efficiency": "GOOD" if avg_cost <= self.performance_targets["max_cost_per_analysis"] else "EXPENSIVE"
        }
        
        return {
            "metrics": self.metrics.copy(),
            "calculated_metrics": {
                "success_rate": success_rate,
                "average_cost_per_analysis": avg_cost,
                "cache_efficiency": self.metrics["cache_hit_rate"]
            },
            "performance_status": performance_status,
            "recommendations": self._generate_optimization_recommendations(performance_status)
        }
```

---

**文档版本**: v1.0  
**创建时间**: 2025-01-15  
**基于技术**: Claude Sonnet API + Redis缓存 + 业务规则引擎  
**维护人员**: AI集成开发团队
# ğŸ“Š è…¾è®¯æ–‡æ¡£æ™ºèƒ½è¯„åˆ†ä½“ç³»è§„èŒƒ (T-RICE+)

**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-09-07  
**çŠ¶æ€**: æ­£å¼å‘å¸ƒ

---

## 1. æ¦‚è¿°

### 1.1 èƒŒæ™¯
åŸºäºå›½é™…æœ€ä½³å®è·µç ”ç©¶ï¼ŒèåˆRICEæ¡†æ¶ã€5Ã—5é£é™©çŸ©é˜µã€DAMAæ•°æ®è´¨é‡æ ‡å‡†ï¼Œä¸º30ä»½è…¾è®¯æ–‡æ¡£è¡¨æ ¼è®¾è®¡çš„ä¼ä¸šçº§æ™ºèƒ½è¯„åˆ†ä½“ç³»ã€‚

### 1.2 æ ¸å¿ƒç›®æ ‡
- **æ ‡å‡†åŒ–è¯„åˆ†**ï¼šä¸º30ä»½è¡¨æ ¼Ã—19åˆ—Ã—æ•°ç™¾å•å…ƒæ ¼æä¾›ç»Ÿä¸€è¯„åˆ†æ ‡å‡†
- **æ™ºèƒ½åŒ–å†³ç­–**ï¼šé€šè¿‡å¤šç»´åº¦è¯„åˆ†æ”¯æŒè‡ªåŠ¨åŒ–å†³ç­–
- **é£é™©åˆ†çº§**ï¼š5çº§é£é™©åˆ†ç±»ç¡®ä¿é‡ç‚¹å…³æ³¨é«˜å±å˜æ›´
- **æ‰¹é‡å¤„ç†**ï¼šä¼˜åŒ–ç®—æ³•æ”¯æŒå¤§è§„æ¨¡è¡¨æ ¼å¹¶å‘è¯„åˆ†

---

## 2. T-RICE+ è¯„åˆ†æ¡†æ¶

### 2.1 æ ¸å¿ƒå…¬å¼

```python
æ€»ä½“è¯„åˆ† = (R Ã— I Ã— C Ã— Q) / E Ã— W

# å‚æ•°å®šä¹‰
R = Reachï¼ˆå½±å“èŒƒå›´ï¼‰     # 25%æƒé‡
I = Impactï¼ˆä¸šåŠ¡å½±å“ï¼‰    # 30%æƒé‡  
C = Confidenceï¼ˆç½®ä¿¡åº¦ï¼‰  # 15%æƒé‡
Q = Qualityï¼ˆè´¨é‡ç»´åº¦ï¼‰   # 15%æƒé‡
E = Effortï¼ˆå¤„ç†æˆæœ¬ï¼‰    # 10%æƒé‡
W = Weightï¼ˆè¡¨æ ¼æƒé‡ï¼‰    # 5%æƒé‡
```

### 2.2 è¯„åˆ†åŒºé—´
- æ€»åˆ†èŒƒå›´ï¼š0.00 - 1.25
- æ ‡å‡†åŒ–åï¼š0.00 - 1.00

---

## 3. å…­ç»´åº¦è¯¦ç»†è¯„åˆ†è§„åˆ™

### 3.1 Reachï¼ˆå½±å“èŒƒå›´ï¼‰ - 25%æƒé‡

#### è®¡ç®—å…¬å¼
```python
def calculate_reach_score(modifications):
    """è®¡ç®—å½±å“èŒƒå›´è¯„åˆ†"""
    modified_cells = len(modifications)
    total_cells = 19 * avg_rows  # 19åˆ— Ã— å¹³å‡è¡Œæ•°
    
    # åŸºç¡€æ¯”ä¾‹
    base_ratio = modified_cells / total_cells
    
    # èŒƒå›´ç³»æ•°
    if is_single_cell(modifications):
        scope_factor = 0.2
    elif is_single_row(modifications):
        scope_factor = 0.4
    elif is_single_column(modifications):
        scope_factor = 0.6
    elif is_multiple_areas(modifications):
        scope_factor = 0.8
    else:  # å…¨è¡¨å½±å“
        scope_factor = 1.0
    
    return min(base_ratio * scope_factor * 1.2, 1.0)
```

#### è¯„åˆ†æ ‡å‡†
| å½±å“èŒƒå›´ | èŒƒå›´ç³»æ•° | å…¸å‹åœºæ™¯ |
|---------|---------|---------|
| å•ä¸ªå•å…ƒæ ¼ | 0.2 | ä¸ªåˆ«æ•°æ®ä¿®æ­£ |
| å•è¡Œå½±å“ | 0.4 | å•æ¡è®°å½•æ›´æ–° |
| å•åˆ—å½±å“ | 0.6 | å­—æ®µæ‰¹é‡æ›´æ–° |
| å¤šè¡Œå¤šåˆ— | 0.8 | ç»“æ„æ€§è°ƒæ•´ |
| å…¨è¡¨å½±å“ | 1.0 | é‡å¤§å˜æ›´ |

### 3.2 Impactï¼ˆä¸šåŠ¡å½±å“ï¼‰ - 30%æƒé‡

#### 19åˆ—æƒé‡åˆ†é…

##### L1çº§å…³é”®åˆ—ï¼ˆæƒé‡1.5ï¼‰
```python
L1_COLUMNS = {
    "æ¥æº": 1.5,
    "ä»»åŠ¡å‘èµ·æ—¶é—´": 1.5,
    "ç›®æ ‡å¯¹é½": 1.5,
    "å…³é”®KRå¯¹é½": 1.5,
    "é‡è¦ç¨‹åº¦": 1.5,
    "é¢„è®¡å®Œæˆæ—¶é—´": 1.5,
    "å®Œæˆè¿›åº¦": 1.5
}
```

##### L2çº§é‡è¦åˆ—ï¼ˆæƒé‡1.2ï¼‰
```python
L2_COLUMNS = {
    "é¡¹ç›®ç±»å‹": 1.2,
    "å…·ä½“è®¡åˆ’å†…å®¹": 1.2,
    "é‚“æ€»æŒ‡å¯¼ç™»è®°": 1.2,
    "è´Ÿè´£äºº": 1.2,
    "ååŠ©äºº": 1.2,
    "ç›‘ç£äºº": 1.2,
    "å®Œæˆé“¾æ¥": 1.2
}
```

##### L3çº§æ™®é€šåˆ—ï¼ˆæƒé‡1.0ï¼‰
```python
L3_COLUMNS = {
    "åºå·": 1.0,
    "æœ€æ–°å¤ç›˜æ—¶é—´": 1.0,
    "å¯¹ä¸Šæ±‡æŠ¥": 1.0,
    "åº”ç”¨æƒ…å†µ": 1.0,
    "ç»ç†åˆ†æå¤ç›˜": 1.0
}
```

#### è®¡ç®—æ–¹æ³•
```python
def calculate_impact_score(modifications):
    """è®¡ç®—ä¸šåŠ¡å½±å“è¯„åˆ†"""
    total_impact = 0
    
    for mod in modifications:
        column_name = mod['column_name']
        change_magnitude = calculate_change_magnitude(
            mod['old_value'], 
            mod['new_value']
        )
        
        # è·å–åˆ—æƒé‡
        column_weight = get_column_weight(column_name)
        
        # ç´¯åŠ å½±å“åˆ†
        total_impact += column_weight * change_magnitude
    
    # å½’ä¸€åŒ–åˆ°0-1
    return min(total_impact / len(modifications), 1.0)
```

### 3.3 Confidenceï¼ˆç½®ä¿¡åº¦ï¼‰ - 15%æƒé‡

#### AIå†³ç­–å› å­
```python
AI_DECISION_FACTORS = {
    "REJECT": 0.4,      # AIæ‹’ç»
    "REVIEW": 0.6,      # éœ€è¦å®¡æ ¸
    "CONDITIONAL": 0.8, # æ¡ä»¶æ‰¹å‡†
    "APPROVE": 1.0      # AIæ‰¹å‡†
}
```

#### æ•°æ®å®Œæ•´æ€§è¯„åˆ†
```python
def calculate_data_completeness(table):
    """è®¡ç®—æ•°æ®å®Œæ•´æ€§"""
    non_empty_cells = count_non_empty(table)
    total_cells = table.rows * table.columns
    
    completeness_ratio = non_empty_cells / total_cells
    
    if completeness_ratio > 0.95:
        return 1.0
    elif completeness_ratio > 0.85:
        return 0.8
    elif completeness_ratio > 0.75:
        return 0.6
    else:
        return 0.4
```

### 3.4 Qualityï¼ˆè´¨é‡ç»´åº¦ï¼‰ - 15%æƒé‡

åŸºäºDAMAå…­ç»´åº¦æ•°æ®è´¨é‡æ ‡å‡†ï¼š

```python
QUALITY_DIMENSIONS = {
    "accuracy": 0.30,      # å‡†ç¡®æ€§
    "completeness": 0.20,  # å®Œæ•´æ€§
    "consistency": 0.20,   # ä¸€è‡´æ€§
    "uniqueness": 0.10,    # å”¯ä¸€æ€§
    "timeliness": 0.10,    # åŠæ—¶æ€§
    "validity": 0.10       # æœ‰æ•ˆæ€§
}

def calculate_quality_score(data):
    """è®¡ç®—è´¨é‡è¯„åˆ†"""
    scores = {
        "accuracy": calculate_accuracy(data),
        "completeness": calculate_completeness(data),
        "consistency": calculate_consistency(data),
        "uniqueness": calculate_uniqueness(data),
        "timeliness": calculate_timeliness(data),
        "validity": calculate_validity(data)
    }
    
    weighted_score = sum(
        scores[dim] * weight 
        for dim, weight in QUALITY_DIMENSIONS.items()
    )
    
    return weighted_score
```

### 3.5 Effortï¼ˆå¤„ç†æˆæœ¬ï¼‰ - 10%æƒé‡

åå‘æŒ‡æ ‡ï¼ˆæˆæœ¬è¶Šé«˜ï¼Œåˆ†æ•°è¶Šä½ï¼‰ï¼š

```python
EFFORT_LEVELS = {
    "automated": 0.1,      # è‡ªåŠ¨å¤„ç†
    "semi_automated": 0.3, # åŠè‡ªåŠ¨å¤„ç†
    "manual_review": 0.5,  # äººå·¥å®¡æ ¸
    "investigation": 0.8,  # æ·±åº¦è°ƒæŸ¥
    "urgent_intervention": 1.0  # ç´§æ€¥å¹²é¢„
}

def calculate_effort_score(change_type):
    """è®¡ç®—å¤„ç†æˆæœ¬è¯„åˆ†"""
    effort_cost = EFFORT_LEVELS.get(change_type, 0.5)
    
    # åå‘è®¡ç®—ï¼šæˆæœ¬è¶Šé«˜ï¼Œåˆ†æ•°è¶Šä½
    return 1 / (1 + effort_cost)
```

### 3.6 Weightï¼ˆè¡¨æ ¼æƒé‡ï¼‰ - 5%æƒé‡

30ä»½è¡¨æ ¼åˆ†çº§ç®¡ç†ï¼š

```python
TABLE_CATEGORIES = {
    # æ ¸å¿ƒä¸šåŠ¡è¡¨ï¼ˆ10ä¸ªï¼‰
    "core_business": {
        "weight": 1.5,
        "tables": [
            "é¡¹ç›®è¿›åº¦è¡¨", "èµ„é‡‘æµæ°´è¡¨", "äººå‘˜åˆ†é…è¡¨",
            "åˆåŒç®¡ç†è¡¨", "é£é™©ç›‘æ§è¡¨", "KPIè€ƒæ ¸è¡¨",
            "é¢„ç®—æ‰§è¡Œè¡¨", "å®¢æˆ·ä¿¡æ¯è¡¨", "äº§å“åº“å­˜è¡¨", "é”€å”®æ•°æ®è¡¨"
        ]
    },
    
    # é‡è¦ä¸šåŠ¡è¡¨ï¼ˆ10ä¸ªï¼‰
    "important_business": {
        "weight": 1.2,
        "tables": [
            "ä¼šè®®è®°å½•è¡¨", "åŸ¹è®­è®¡åˆ’è¡¨", "é‡‡è´­æ¸…å•è¡¨",
            "è€ƒå‹¤ç»Ÿè®¡è¡¨", "æŠ¥é”€æ˜ç»†è¡¨", "è®¾å¤‡ç®¡ç†è¡¨",
            "ä¾›åº”å•†è¡¨", "è´¨é‡æ£€æŸ¥è¡¨", "ç»´ä¿®è®°å½•è¡¨", "è®¿å®¢ç™»è®°è¡¨"
        ]
    },
    
    # è¾…åŠ©ä¸šåŠ¡è¡¨ï¼ˆ10ä¸ªï¼‰
    "auxiliary_business": {
        "weight": 1.0,
        "tables": [
            "å¤‡å¿˜å½•è¡¨", "å‚è€ƒèµ„æ–™è¡¨", "å†å²è®°å½•è¡¨",
            "é€šè®¯å½•è¡¨", "èŠ‚å‡æ—¥è¡¨", "å€¼ç­å®‰æ’è¡¨",
            "å›¾ä¹¦å€Ÿé˜…è¡¨", "è½¦è¾†ä½¿ç”¨è¡¨", "ä¼šè®®å®¤é¢„å®šè¡¨", "æ„è§åé¦ˆè¡¨"
        ]
    }
}
```

---

## 4. é£é™©ç­‰çº§æ˜ å°„

### 4.1 5Ã—5é£é™©çŸ©é˜µ

```python
RISK_MATRIX = [
    # å½±å“åº¦ â†’
    # â†“ æ¦‚ç‡   æä½    ä½     ä¸­     é«˜    æé«˜
    [0.05, 0.10, 0.15, 0.20, 0.25],  # æä½æ¦‚ç‡
    [0.10, 0.20, 0.30, 0.40, 0.50],  # ä½æ¦‚ç‡
    [0.15, 0.30, 0.45, 0.60, 0.75],  # ä¸­æ¦‚ç‡
    [0.20, 0.40, 0.60, 0.80, 1.00],  # é«˜æ¦‚ç‡
    [0.25, 0.50, 0.75, 1.00, 1.25],  # æé«˜æ¦‚ç‡
]
```

### 4.2 é£é™©ç­‰çº§å®šä¹‰

| é£é™©ç­‰çº§ | åˆ†æ•°åŒºé—´ | æ ‡è¯† | å¤„ç†ç­–ç•¥ | SLA |
|---------|---------|------|---------|-----|
| æé«˜é£é™© | 0.80-1.25 | ğŸ”´ | ç«‹å³å‡çº§ï¼Œäººå·¥ä»‹å…¥ | 15åˆ†é’Ÿ |
| é«˜é£é™© | 0.60-0.80 | ğŸŸ  | ä¼˜å…ˆå¤„ç†ï¼Œå»ºè®®å®¡æ ¸ | 1å°æ—¶ |
| ä¸­é£é™© | 0.40-0.60 | ğŸŸ¡ | å¸¸è§„ç›‘æ§ï¼Œå®šæœŸæ£€æŸ¥ | 4å°æ—¶ |
| ä½é£é™© | 0.20-0.40 | ğŸŸ¢ | è‡ªåŠ¨é€šè¿‡ï¼Œè®°å½•å¤‡æ¡ˆ | 24å°æ—¶ |
| æä½é£é™© | 0.00-0.20 | âšª | å¿½ç•¥å˜æ›´ï¼Œä»…åšæ—¥å¿— | æ— éœ€å¤„ç† |

---

## 5. ICEå¿«é€Ÿè¯„åˆ†æ¨¡å‹

### 5.1 åº”ç”¨åœºæ™¯
å½“éœ€è¦å¿«é€Ÿå†³ç­–æˆ–èµ„æºæœ‰é™æ—¶ï¼Œä½¿ç”¨ICEç®€åŒ–è¯„åˆ†ï¼š

```python
def calculate_ice_score(change):
    """ICEå¿«é€Ÿè¯„åˆ†"""
    impact = rate_impact(change)        # 1-10åˆ†
    confidence = rate_confidence(change) # 0-100%
    ease = rate_ease(change)            # 1-10åˆ†
    
    ice_score = impact * confidence * ease
    
    return {
        "score": ice_score,
        "decision": get_ice_decision(ice_score)
    }

def get_ice_decision(score):
    """ICEå†³ç­–é˜ˆå€¼"""
    if score > 500:
        return "IMMEDIATE"  # ç«‹å³å¤„ç†
    elif score > 200:
        return "PLANNED"    # è®¡åˆ’å¤„ç†
    else:
        return "DEFERRED"   # æš‚ç¼“å¤„ç†
```

---

## 6. æ‰¹é‡å¤„ç†ç®—æ³•

### 6.1 æ™ºèƒ½æ‰¹å¤„ç†æ¶æ„

```python
class BatchScoringEngine:
    """30ä»½è¡¨æ ¼æ‰¹é‡è¯„åˆ†å¼•æ“"""
    
    def __init__(self):
        self.batch_size = 5        # æ¯æ‰¹5ä¸ªè¡¨æ ¼
        self.parallel_workers = 3   # 3ä¸ªå¹¶å‘å¤„ç†å™¨
        self.cache_ttl = 86400     # 24å°æ—¶ç¼“å­˜
        self.redis_client = Redis()
        
    async def process_all_tables(self, tables):
        """æ‰¹é‡å¤„ç†30ä»½è¡¨æ ¼"""
        # 1. æ™ºèƒ½åˆ†ç»„
        groups = self.intelligent_grouping(tables)
        
        # 2. å¹¶è¡Œå¤„ç†
        tasks = []
        for group in groups:
            task = asyncio.create_task(
                self.process_group(group)
            )
            tasks.append(task)
        
        # 3. æ”¶é›†ç»“æœ
        results = await asyncio.gather(*tasks)
        
        # 4. èšåˆè¯„åˆ†
        return self.aggregate_results(results)
    
    def intelligent_grouping(self, tables):
        """åŸºäºç›¸ä¼¼åº¦å’Œé‡è¦æ€§åˆ†ç»„"""
        groups = []
        
        # æŒ‰è¡¨æ ¼ç±»åˆ«åˆ†ç»„
        for category in ['core', 'important', 'auxiliary']:
            category_tables = [
                t for t in tables 
                if t.category == category
            ]
            
            # æŒ‰æ‰¹æ¬¡å¤§å°åˆ†å‰²
            for i in range(0, len(category_tables), self.batch_size):
                groups.append(
                    category_tables[i:i+self.batch_size]
                )
        
        return groups
```

### 6.2 ç¼“å­˜ç­–ç•¥

```python
def get_cached_score(self, table_id, modification_hash):
    """è·å–ç¼“å­˜çš„è¯„åˆ†ç»“æœ"""
    cache_key = f"score:{table_id}:{modification_hash}"
    
    cached = self.redis_client.get(cache_key)
    if cached:
        self.stats['cache_hits'] += 1
        return json.loads(cached)
    
    return None

def cache_score(self, table_id, modification_hash, score):
    """ç¼“å­˜è¯„åˆ†ç»“æœ"""
    cache_key = f"score:{table_id}:{modification_hash}"
    
    self.redis_client.setex(
        cache_key,
        self.cache_ttl,
        json.dumps(score)
    )
```

---

## 7. è¯„åˆ†è¾“å‡ºè§„èŒƒ

### 7.1 æ ‡å‡†è¾“å‡ºæ ¼å¼

```json
{
  "summary": {
    "overall_score": 0.62,
    "risk_level": "HIGH",
    "trend": "INCREASING",
    "attention_items": 15,
    "processed_tables": 30,
    "processing_time": 3.2
  },
  
  "risk_distribution": {
    "extreme_high": {"count": 2, "percentage": 6.7},
    "high": {"count": 5, "percentage": 16.7},
    "medium": {"count": 8, "percentage": 26.7},
    "low": {"count": 10, "percentage": 33.3},
    "extreme_low": {"count": 5, "percentage": 16.7}
  },
  
  "column_analysis": {
    "highest_risk": {
      "column": "è´Ÿè´£äºº",
      "score": 0.85,
      "changes": 32
    },
    "most_modified": {
      "column": "ç»ç†åˆ†æå¤ç›˜",
      "count": 145
    },
    "highest_impact": {
      "column": "é¢„è®¡å®Œæˆæ—¶é—´",
      "affected_tables": 12
    }
  },
  
  "top_tables": [
    {
      "name": "é¡¹ç›®è¿›åº¦è¡¨",
      "score": 0.89,
      "risk_level": "EXTREME_HIGH",
      "recommendation": "ç«‹å³å®¡æ ¸",
      "key_changes": [
        "è´Ÿè´£äººå˜æ›´3æ¬¡",
        "å®Œæˆæ—¶é—´æ¨è¿Ÿ2å‘¨",
        "é¢„ç®—å¢åŠ 20%"
      ]
    }
  ],
  
  "recommendations": [
    "å»ºè®®ç«‹å³å®¡æ ¸é¡¹ç›®è¿›åº¦è¡¨çš„è´Ÿè´£äººå˜æ›´",
    "å…³æ³¨èµ„é‡‘æµæ°´è¡¨çš„å¼‚å¸¸æ³¢åŠ¨",
    "å®šæœŸæ£€æŸ¥é¢„è®¡å®Œæˆæ—¶é—´çš„æ‰¹é‡ä¿®æ”¹"
  ]
}
```

### 7.2 å¯è§†åŒ–è¦æ±‚

è¯„åˆ†ç»“æœéœ€æ”¯æŒä»¥ä¸‹å¯è§†åŒ–å±•ç¤ºï¼š
1. **ä»ªè¡¨ç›˜**ï¼šæ€»ä½“é£é™©è¯„åˆ†è¡¨ç›˜
2. **é¥¼å›¾**ï¼šé£é™©ç­‰çº§åˆ†å¸ƒ
3. **æŸ±çŠ¶å›¾**ï¼šåˆ—ç»´åº¦é£é™©å¯¹æ¯”
4. **è¶‹åŠ¿å›¾**ï¼šå†å²è¯„åˆ†è¶‹åŠ¿
5. **çƒ­åŠ›è¡¨**ï¼š30Ã—19çŸ©é˜µé£é™©çƒ­åº¦

---

## 8. å®æ–½è®¡åˆ’

### 8.1 éƒ¨ç½²é˜¶æ®µ
1. **Phase 1**ï¼ˆç¬¬1å‘¨ï¼‰ï¼šæ ¸å¿ƒè¯„åˆ†å¼•æ“å¼€å‘
2. **Phase 2**ï¼ˆç¬¬2å‘¨ï¼‰ï¼šæ‰¹å¤„ç†ä¼˜åŒ–å’Œç¼“å­˜å®ç°
3. **Phase 3**ï¼ˆç¬¬3å‘¨ï¼‰ï¼šAPIæ¥å£å’Œå¯è§†åŒ–å¼€å‘
4. **Phase 4**ï¼ˆç¬¬4å‘¨ï¼‰ï¼šæµ‹è¯•ä¼˜åŒ–å’Œä¸Šçº¿

### 8.2 æ€§èƒ½æŒ‡æ ‡
- å•è¡¨è¯„åˆ†è€—æ—¶ï¼š< 100ms
- 30è¡¨æ‰¹é‡è¯„åˆ†ï¼š< 3ç§’
- ç¼“å­˜å‘½ä¸­ç‡ï¼š> 70%
- APIå“åº”æ—¶é—´ï¼š< 200ms
- å¹¶å‘å¤„ç†èƒ½åŠ›ï¼š100 QPS

---

## 9. ç»´æŠ¤å’Œä¼˜åŒ–

### 9.1 å®šæœŸæ ¡å‡†
- **æ¯å‘¨**ï¼šæ£€æŸ¥è¯„åˆ†é˜ˆå€¼åˆç†æ€§
- **æ¯æœˆ**ï¼šè°ƒæ•´åˆ—æƒé‡åˆ†é…
- **æ¯å­£åº¦**ï¼šä¼˜åŒ–è¯„åˆ†ç®—æ³•
- **æ¯åŠå¹´**ï¼šå…¨é¢è¯„ä¼°ä½“ç³»æ•ˆæœ

### 9.2 åé¦ˆæœºåˆ¶
```python
class FeedbackLoop:
    """è¯„åˆ†åé¦ˆå’Œè‡ªåŠ¨ä¼˜åŒ–"""
    
    def collect_feedback(self, score_id, actual_risk):
        """æ”¶é›†å®é™…é£é™©åé¦ˆ"""
        predicted_risk = self.get_predicted_risk(score_id)
        
        # è®¡ç®—åå·®
        deviation = abs(predicted_risk - actual_risk)
        
        # è®°å½•åé¦ˆ
        self.feedback_db.insert({
            "score_id": score_id,
            "predicted": predicted_risk,
            "actual": actual_risk,
            "deviation": deviation,
            "timestamp": datetime.now()
        })
        
    def auto_calibrate(self):
        """åŸºäºåé¦ˆè‡ªåŠ¨æ ¡å‡†æƒé‡"""
        recent_feedback = self.get_recent_feedback(days=30)
        
        if len(recent_feedback) > 100:
            # ä½¿ç”¨æœºå™¨å­¦ä¹ ä¼˜åŒ–æƒé‡
            new_weights = self.ml_optimizer.optimize(
                recent_feedback
            )
            
            # æ›´æ–°æƒé‡é…ç½®
            self.update_weights(new_weights)
```

---

## 10. é™„å½•

### 10.1 å‚è€ƒæ ‡å‡†
- RICE Framework (Intercom)
- ICE Scoring Model
- WSJF (SAFe)
- DAMA-DMBOK Data Quality Dimensions
- ISO 8000 Data Quality Standards

### 10.2 ç‰ˆæœ¬å†å²
| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹å†…å®¹ | ä½œè€… |
|-----|------|---------|------|
| v1.0 | 2025-09-07 | åˆå§‹ç‰ˆæœ¬å‘å¸ƒ | ç³»ç»Ÿç”Ÿæˆ |

### 10.3 è”ç³»æ–¹å¼
- æŠ€æœ¯æ”¯æŒï¼šai-scoring@tencent-docs.com
- åé¦ˆæ¸ é“ï¼šhttp://feedback.tencent-docs.com/scoring

---

*æœ¬è§„èŒƒåŸºäºå›½é™…æœ€ä½³å®è·µå’Œè…¾è®¯æ–‡æ¡£å®é™…éœ€æ±‚åˆ¶å®šï¼Œå°†æŒç»­ä¼˜åŒ–è¿­ä»£ã€‚*
# 📊 详细分表打分方法规范 v3.0

**版本**: v3.0  
**更新日期**: 2025-09-11  
**状态**: 生产强制执行版  
**核心原则**: **统一标准、强制阈值、禁止降级**

---

## ⚠️ 关键要求

**本规范严格禁止以下行为**：
1. ❌ 任何形式的降级方法（fallback）
2. ❌ 使用DetailedScoreGenerator或其他评分器
3. ❌ L1列变更分数低于0.8（红色阈值）
4. ❌ L2列变更分数低于0.6（橙色阈值）

**必须确保**：
- ✅ 统一使用IntegratedScorer作为唯一评分器
- ✅ L1列任何变更触发红色警告（>=0.8分）
- ✅ L2列任何变更触发橙色警告（>=0.6分）
- ✅ 严格执行风险控制原则

---

## 1. 系统架构总览

### 1.1 三层差异化打分策略

| 列级别 | 风险等级 | 基础分 | 最低分数 | 警告颜色 | 处理方式 | 列数量 |
|--------|---------|--------|---------|---------|---------|--------|
| **L1** | 极高风险 | 0.8 | 0.8 | 🔴红色 | 纯规则+强制阈值 | 7列 |
| **L2** | 高风险 | 0.5 | 0.6 | 🟠橙色 | 规则+强制阈值 | 7列 |
| **L3** | 一般风险 | 0.2 | 无 | 动态 | 标准计算 | 5列 |

### 1.2 核心打分公式

```
最终得分 = 基础分 × 变更系数 × 列权重 × AI调整系数 × 置信度权重
```

其中：
- **基础分**：L1=0.8, L2=0.5, L3=0.2
- **变更系数**：根据修改类型计算（0.0-1.3）
- **列权重**：特定列的业务重要性（1.0-1.4）
- **AI调整系数**：仅L2列，基于AI决策（0.6-1.5）
- **置信度权重**：仅L2列，基于AI置信度（0.7-1.0）

---

## 2. L1列规则打分（高风险）

### 2.1 L1列定义与业务含义

```python
L1_COLUMNS = [
    "来源",           # 数据来源标识，不可随意修改
    "任务发起时间",    # 关键时间节点，影响整体进度
    "目标对齐",       # 战略目标关联，不可偏离主线
    "关键KR对齐",     # 核心KPI关联，不可随意调整
    "重要程度",       # 优先级标识，不可随意降级
    "预计完成时间",    # 交付承诺，不可无故延期
    "完成进度"        # 执行状态，不可虚假填报
]
```

### 2.2 L1打分算法

```python
def process_l1_modification(mod: Dict) -> Dict:
    """L1列打分（纯规则，无AI）"""
    
    # Step 1: 基础分
    base_score = 0.8  # L1固定基础分
    
    # Step 2: 变更系数计算
    old_value = str(mod.get('old_value', '')).strip()
    new_value = str(mod.get('new_value', '')).strip()
    
    if old_value == new_value:
        change_factor = 0.0  # 无变化
    elif not old_value and new_value:
        change_factor = 1.0  # 补充信息
    elif old_value and not new_value:
        change_factor = 1.3  # 删除内容（最危险）
    elif '延期' in new_value or '推迟' in new_value:
        change_factor = 1.2  # 包含风险关键词
    else:
        change_factor = 1.1  # 一般修改
    
    # Step 3: 列权重
    column_weights = {
        "重要程度": 1.4,
        "任务发起时间": 1.3,
        "预计完成时间": 1.3,
        "完成进度": 1.1,
        "邓总指导登记": 1.15
    }
    importance_weight = column_weights.get(mod['column_name'], 1.0)
    
    # Step 4: 计算最终分数
    final_score = min(base_score * change_factor * importance_weight, 1.0)
    
    return {
        'base_score': base_score,
        'change_factor': change_factor,
        'importance_weight': importance_weight,
        'ai_adjustment': 1.0,  # L1不使用AI
        'confidence_weight': 1.0,  # L1不使用AI
        'final_score': final_score,
        'ai_used': False,
        'ai_reason': 'L1_column_rule_based'
    }
```

### 2.3 L1预期效果案例

| 案例 | 修改内容 | 计算过程 | 最终得分 | 风险等级 |
|------|---------|----------|---------|---------|
| 重要程度降级 | 高→中 | 0.8×1.1×1.4 | 1.0 | 极高风险🔴 |
| 延期交付 | 3月→4月 | 0.8×1.2×1.3 | 1.0 | 极高风险🔴 |
| 删除进度 | 80%→空 | 0.8×1.3×1.1 | 1.0 | 极高风险🔴 |
| 补充来源 | 空→内部 | 0.8×1.0×1.0 | 0.8 | 高风险🟠 |

---

## 3. L3列规则打分（低风险）

### 3.1 L3列定义与业务含义

```python
L3_COLUMNS = [
    "序号",          # 顺序标识，仅格式作用
    "复盘时间",      # 回顾时间，记录性质
    "对上汇报",      # 汇报记录，非关键信息
    "应用情况",      # 使用情况，参考信息
    "进度分析总结"    # 总结文本，辅助信息
]
```

### 3.2 L3打分算法

```python
def process_l3_modification(mod: Dict) -> Dict:
    """L3列打分（纯规则，无AI）"""
    
    # Step 1: 基础分
    base_score = 0.2  # L3固定基础分
    
    # Step 2: 变更系数计算（较宽松）
    old_value = str(mod.get('old_value', '')).strip()
    new_value = str(mod.get('new_value', '')).strip()
    
    if old_value == new_value:
        change_factor = 0.0  # 无变化
    elif not old_value and new_value:
        change_factor = 0.8  # 补充总结（好事）
    elif old_value and not new_value:
        change_factor = 1.0  # 清空内容
    elif abs(len(new_value) - len(old_value)) < 10:
        change_factor = 0.3  # 微小调整
    else:
        change_factor = 0.5  # 一般修改
    
    # Step 3: L3列无特殊权重
    importance_weight = 1.0
    
    # Step 4: 计算最终分数
    final_score = base_score * change_factor * importance_weight
    
    return {
        'base_score': base_score,
        'change_factor': change_factor,
        'importance_weight': importance_weight,
        'ai_adjustment': 1.0,  # L3不使用AI
        'confidence_weight': 1.0,  # L3不使用AI
        'final_score': final_score,
        'ai_used': False,
        'ai_reason': 'L3_column_rule_based'
    }
```

### 3.3 L3预期效果案例

| 案例 | 修改内容 | 计算过程 | 最终得分 | 风险等级 |
|------|---------|----------|---------|---------|
| 序号调整 | 1→01 | 0.2×0.3×1.0 | 0.06 | 极低风险🔵 |
| 补充总结 | 空→已完成 | 0.2×0.8×1.0 | 0.16 | 极低风险🔵 |
| 清空复盘时间 | 9月→空 | 0.2×1.0×1.0 | 0.20 | 低风险🟢 |
| 更新汇报 | 简要→详细 | 0.2×0.5×1.0 | 0.10 | 极低风险🔵 |

---

## 4. L2列AI语义分析集成（中风险）【核心】

### 4.1 L2列定义与业务含义

```python
L2_COLUMNS = [
    "项目类型",          # 项目性质，需要判断变更合理性
    "具体计划内容",      # 详细描述，需要分析实质变化
    "邓总指导登记",      # 领导批示，需要谨慎处理
    "负责人",           # 责任人，人员变更需要评估
    "协助人",           # 协作者，团队调整影响分析
    "监督人",           # 监督者，监督链完整性检查
    "形成计划清单"       # 计划列表，可行性分析
]
```

### 4.2 L2 AI语义分析调用链【关键】

#### 4.2.1 数据准备

```python
def prepare_l2_data_for_ai(mod: Dict) -> Dict:
    """准备L2修改数据用于AI分析"""
    return {
        'modification_id': f"M{mod.get('index', 1):03d}",
        'cell': mod.get('cell', ''),
        'column_name': mod['column_name'],
        'old_value': mod.get('old_value', ''),
        'new_value': mod.get('new_value', ''),
        'table_name': mod.get('table_name', ''),
        'row_number': mod.get('row_number', 0),
        'context': {
            'same_row': mod.get('row_context', {}),  # 同行其他列
            'history': mod.get('change_history', [])  # 历史修改
        }
    }
```

#### 4.2.2 调用AI服务（必须成功）

```python
def call_l2_semantic_service(mod: Dict) -> Dict:
    """
    调用L2语义分析服务
    
    重要：不允许任何降级！如果AI服务不可用，必须报错
    """
    
    # 方案A：调用8098端口服务
    try:
        response = requests.post(
            'http://localhost:8098/api/semantic_analysis',
            json={'modifications': [prepare_l2_data_for_ai(mod)]},
            timeout=5
        )
        
        if response.status_code != 200:
            raise Exception(f"AI服务返回错误: {response.status_code}")
        
        result = response.json()
        return result['results'][0] if result.get('results') else None
        
    except Exception as e:
        # 不允许降级！必须报错
        raise Exception(f"L2 AI语义分析服务调用失败: {e}")
    
    # 方案B：直接调用L2SemanticAnalyzer
    from production.core_modules.l2_semantic_analysis_two_layer import L2SemanticAnalyzer
    
    analyzer = L2SemanticAnalyzer(api_client=deepseek_client)
    result = analyzer.analyze_single_modification(mod)  # 需要添加此方法
    
    if not result:
        raise Exception("L2 AI分析返回空结果")
    
    return result
```

#### 4.2.3 解析AI结果

```python
def parse_l2_ai_result(ai_result: Dict) -> Tuple[float, float, Dict]:
    """
    解析AI分析结果
    
    Returns:
        (ai_adjustment_factor, confidence, full_analysis)
    """
    
    # 提取两层分析结果
    layer1_result = ai_result.get('layer1_result', {})
    layer2_result = ai_result.get('layer2_result', {})
    
    # 获取最终决策
    final_decision = ai_result.get('final_decision')
    if not final_decision and layer2_result:
        final_decision = layer2_result.get('decision', 'UNSURE')
    elif not final_decision and layer1_result:
        judgment = layer1_result.get('judgment', 'UNSURE')
        final_decision = 'APPROVE' if judgment == 'SAFE' else 'REVIEW'
    else:
        final_decision = 'UNSURE'
    
    # 决策映射到调整系数
    AI_DECISION_FACTORS = {
        'APPROVE': 0.6,      # AI批准，降低40%风险
        'CONDITIONAL': 0.8,  # 条件通过，降低20%风险
        'REVIEW': 1.2,       # 需要审核，提高20%风险
        'REJECT': 1.5,       # AI拒绝，提高50%风险
        'UNSURE': 1.0        # 不确定，不调整
    }
    
    ai_factor = AI_DECISION_FACTORS.get(final_decision, 1.0)
    
    # 获取置信度
    if layer2_result:
        confidence = layer2_result.get('confidence', 70)
    elif layer1_result:
        confidence = layer1_result.get('confidence', 50)
    else:
        confidence = 50
    
    # 构建完整分析结果
    full_analysis = {
        'layer1_result': layer1_result,
        'layer2_result': layer2_result,
        'final_decision': final_decision,
        'confidence': confidence,
        'key_risks': layer2_result.get('key_risks', []) if layer2_result else [],
        'recommendation': layer2_result.get('recommendation', '') if layer2_result else ''
    }
    
    return ai_factor, confidence, full_analysis
```

#### 4.2.4 综合打分计算

```python
def process_l2_modification(mod: Dict) -> Dict:
    """
    L2列打分（AI语义分析+规则）
    
    核心：必须使用AI，不允许降级
    """
    
    # Step 1: 基础分
    base_score = 0.5  # L2固定基础分
    
    # Step 2: 规则部分
    old_value = str(mod.get('old_value', '')).strip()
    new_value = str(mod.get('new_value', '')).strip()
    
    # 变更系数
    if old_value == new_value:
        change_factor = 0.0
    elif not old_value and new_value:
        change_factor = 0.9  # 补充信息
    elif old_value and not new_value:
        change_factor = 1.2  # 删除内容
    else:
        change_factor = 1.0  # 一般修改
    
    # 列权重
    column_weights = {
        "负责人": 1.2,
        "邓总指导登记": 1.15,
        "项目类型": 1.1
    }
    importance_weight = column_weights.get(mod['column_name'], 1.0)
    
    # Step 3: AI分析（必须成功）
    ai_result = call_l2_semantic_service(mod)
    ai_factor, confidence, full_analysis = parse_l2_ai_result(ai_result)
    
    # Step 4: 置信度加权
    if confidence >= 90:
        confidence_weight = 1.0
    elif confidence >= 70:
        confidence_weight = 0.9
    elif confidence >= 50:
        confidence_weight = 0.8
    else:
        confidence_weight = 0.7
    
    # Step 5: 综合计算
    final_score = min(
        base_score * change_factor * importance_weight * ai_factor * confidence_weight,
        1.0
    )
    
    return {
        'base_score': base_score,
        'change_factor': change_factor,
        'importance_weight': importance_weight,
        'ai_adjustment': ai_factor,
        'confidence_weight': confidence_weight,
        'final_score': final_score,
        'ai_used': True,
        'ai_analysis': full_analysis
    }
```

### 4.3 L2预期效果案例

| 案例 | 修改内容 | AI决策 | 计算过程 | 最终得分 | 风险等级 |
|------|---------|--------|---------|---------|---------|
| 项目类型变更 | 目标管理→体系建设 | REVIEW(85%) | 0.5×1.0×1.1×1.2×0.9 | 0.594 | 中风险🟡 |
| 增加协助人 | 张三→张三,李四 | APPROVE(90%) | 0.5×0.9×1.0×0.6×1.0 | 0.270 | 低风险🟢 |
| 删除领导批示 | 重要→空 | REJECT(95%) | 0.5×1.2×1.15×1.5×1.0 | 1.0 | 极高风险🔴 |
| 负责人变更 | 王五→赵六 | CONDITIONAL(75%) | 0.5×1.0×1.2×0.8×0.9 | 0.432 | 中风险🟡 |

---

## 5. 详细打分文件输出格式

### 5.1 文件路径规范

```
/root/projects/tencent-doc-manager/
└── scoring_results/
    └── detailed/
        ├── detailed_score_副本-测试版本-出国销售计划表_20250908_153045.json
        ├── detailed_score_副本-测试版本-回国销售计划表_20250908_153146.json
        └── detailed_score_测试版本-小红书部门_20250908_153247.json
```

### 5.2 完整JSON输出格式

```json
{
  "metadata": {
    "table_name": "副本-测试版本-出国销售计划表",
    "table_url": "https://docs.qq.com/sheet/DWEFNU25TemFnZXJN",
    "source_file": "/comparison_results/simplified_xxx_20250908.json",
    "scoring_time": "2025-09-08 15:30:45",
    "total_modifications": 25,
    "scoring_version": "v2.0",
    "ai_service": {
      "status": "active",
      "endpoint": "http://localhost:8098",
      "mode": "two_layer_analysis"
    }
  },
  
  "scores": [
    {
      "modification_id": "M001",
      "cell": "C4",
      "row_number": 4,
      "column_name": "项目类型",
      "column_level": "L2",
      "old_value": "目标管理",
      "new_value": "体系建设",
      
      "scoring_components": {
        "base_score": 0.5,
        "change_factor": 1.0,
        "column_weight": 1.1,
        "ai_adjustment": 1.2,
        "confidence_weight": 0.9,
        "calculation": "0.5 × 1.0 × 1.1 × 1.2 × 0.9 = 0.594"
      },
      
      "ai_analysis": {
        "enabled": true,
        "service_used": "8098_semantic_api",
        "processing_time": "0.47s",
        
        "layer1_result": {
          "judgment": "UNSURE",
          "confidence": 60,
          "reason": "项目性质发生实质改变"
        },
        
        "layer2_result": {
          "decision": "REVIEW",
          "risk_level": "MEDIUM",
          "confidence": 85,
          "key_risks": [
            "项目类型从管理转向建设",
            "可能影响资源分配",
            "需要确认变更原因"
          ],
          "recommendation": "建议项目负责人说明变更原因和预期影响"
        },
        
        "final_decision": "REVIEW"
      },
      
      "final_score": 0.594,
      "risk_level": "MEDIUM",
      "risk_color": "yellow",
      "risk_icon": "🟡",
      "action_required": "manual_review",
      "priority": 3
    },
    
    {
      "modification_id": "M002",
      "cell": "D5",
      "row_number": 5,
      "column_name": "重要程度",
      "column_level": "L1",
      "old_value": "高",
      "new_value": "中",
      
      "scoring_components": {
        "base_score": 0.8,
        "change_factor": 1.1,
        "column_weight": 1.4,
        "ai_adjustment": 1.0,
        "confidence_weight": 1.0,
        "calculation": "0.8 × 1.1 × 1.4 × 1.0 × 1.0 = 1.232 → 1.0"
      },
      
      "ai_analysis": {
        "enabled": false,
        "reason": "L1_column_rule_based"
      },
      
      "final_score": 1.0,
      "risk_level": "EXTREME_HIGH",
      "risk_color": "red",
      "risk_icon": "🔴",
      "action_required": "immediate_review",
      "priority": 1
    }
  ],
  
  "summary": {
    "total_score": 15.234,
    "average_score": 0.609,
    
    "risk_distribution": {
      "EXTREME_HIGH": 2,
      "HIGH": 5,
      "MEDIUM": 8,
      "LOW": 7,
      "EXTREME_LOW": 3
    },
    
    "column_level_stats": {
      "L1": {
        "count": 8,
        "avg_score": 0.875,
        "max_score": 1.0
      },
      "L2": {
        "count": 10,
        "avg_score": 0.523,
        "ai_calls": 10,
        "ai_failures": 0
      },
      "L3": {
        "count": 7,
        "avg_score": 0.142,
        "max_score": 0.2
      }
    },
    
    "ai_statistics": {
      "total_l2_modifications": 10,
      "ai_calls_made": 10,
      "layer1_only": 6,
      "layer2_analyzed": 4,
      "average_confidence": 82.5,
      "decision_distribution": {
        "APPROVE": 3,
        "CONDITIONAL": 2,
        "REVIEW": 4,
        "REJECT": 1
      }
    },
    
    "processing_metrics": {
      "total_time": "2.34s",
      "ai_processing_time": "1.89s",
      "rule_processing_time": "0.45s",
      "average_per_modification": "0.094s"
    }
  }
}
```

---

## 6. 关键实现要求

### 6.1 强制要求

1. **禁止降级**
   - L2列必须调用AI语义分析
   - AI服务不可用时必须报错，不允许fallback
   - 不允许使用mock或模拟数据

2. **数据完整性**
   - AI分析结果必须完整保存
   - 每个打分组件都要记录
   - 保留计算过程用于审计

3. **服务依赖**
   - 确保8098端口语义分析服务运行
   - 配置真实的DeepSeek API密钥
   - 实现两层AI架构（快速筛选+深度分析）

### 6.2 性能要求

- 单个修改处理时间 < 200ms（不含AI）
- AI分析响应时间 < 2s
- 批量处理支持并发

### 6.3 错误处理

```python
def handle_scoring_error(mod: Dict, error: Exception) -> Dict:
    """
    错误处理（不允许降级）
    """
    # 记录错误但不降级
    logger.error(f"打分失败: {error}")
    
    # 必须抛出异常，不允许返回默认值
    raise Exception(f"无法完成打分: {error}")
```

---

## 7. 系统集成点

### 7.1 上游输入
- **来源**: 列标准化后的简化对比JSON
- **路径**: `/comparison_results/simplified_*.json`
- **格式**: 标准化的modifications数组

### 7.2 处理流程
1. 读取简化对比文件
2. 按列级别分类（L1/L2/L3）
3. L1/L3使用规则打分
4. L2调用AI语义分析
5. 综合计算最终得分
6. 生成详细打分文件

### 7.3 下游输出
- **消费者**: 综合汇总器（comprehensive_aggregator.py）
- **用途**: 生成列级风险报告
- **格式**: 详细打分JSON文件

---

## 8. 测试验证

### 8.1 L1列测试用例
```python
# 测试高风险修改
test_l1 = {
    'column_name': '重要程度',
    'old_value': '高',
    'new_value': '低'
}
# 预期: final_score = 1.0 (极高风险)
```

### 8.2 L2列测试用例
```python
# 测试AI分析
test_l2 = {
    'column_name': '项目类型',
    'old_value': '研发',
    'new_value': '运营'
}
# 预期: 调用AI服务，返回REVIEW决策
```

### 8.3 L3列测试用例
```python
# 测试低风险修改
test_l3 = {
    'column_name': '序号',
    'old_value': '1',
    'new_value': '01'
}
# 预期: final_score < 0.2 (极低风险)
```

---

## 9. 常见问题

### Q1: AI服务调用失败怎么办？
**A**: 必须报错，不允许降级。检查8098端口服务状态。

### Q2: 如何添加新的L2列？
**A**: 更新L2_COLUMNS数组，确保AI提示词包含新列的业务含义。

### Q3: 打分结果不合理怎么调整？
**A**: 调整列权重或AI决策映射系数，但不能跳过AI分析。

---

## 10. 版本历史

- v2.0 (2025-09-08): 禁止降级方法，强制L2使用AI
- v1.0 (2025-09-07): 初始版本

---

**文档维护**: 腾讯文档智能监控系统团队  
**最后更新**: 2025-09-08  
**状态**: 生产环境强制执行
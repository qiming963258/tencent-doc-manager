# 10-综合打分全链路适配规范

## 📋 文档概述

**版本**: 4.0（统一规范版）
**更新日期**: 2025-09-16
**状态**: ✅ **统一管理规范**
**目的**: 定义从CSV对比到UI展示的完整数据链路，统一打分算法，集中配置管理

### 📌 本规范的职责范围
- **包含**: 标准列定义、L1/L2/L3分类、打分算法、数据链路、UI参数映射
- **不包含**: 热力图渲染算法（见09规范）、配置文件格式（见11规范）

---

## 第一部分：标准列定义与风险分级

### 🔐 标准19列定义（唯一权威）

```python
# 这是整个系统的唯一标准列定义
# 同步位置：/root/projects/tencent-doc-manager/standard_columns_config.py
STANDARD_COLUMNS = [
    "序号",           # 0 - L3
    "项目类型",       # 1 - L2
    "来源",           # 2 - L1
    "任务发起时间",   # 3 - L1
    "目标对齐",       # 4 - L1
    "关键KR对齐",     # 5 - L1
    "具体计划内容",   # 6 - L2
    "邓总指导登记",   # 7 - L2
    "负责人",         # 8 - L2
    "协助人",         # 9 - L2
    "监督人",         # 10 - L2
    "重要程度",       # 11 - L1
    "预计完成时间",   # 12 - L1
    "完成进度",       # 13 - L1
    "完成链接",       # 14 - L3（修正：原为"完成链接"）
    "经理分析复盘",   # 15 - L3（修正：原为"最新复盘时间"）
    "最新复盘时间",   # 16 - L3（新增）
    "对上汇报",       # 17 - L3
    "应用情况"        # 18 - L3（修正：原为"经理分析复盘"）
]
```

### 🎯 L1/L2/L3风险分级定义

#### L1级 - 极高风险列（7列）
```python
L1_COLUMNS = [
    "来源",           # 数据来源变更影响分析基础
    "任务发起时间",   # 时间线变更影响项目计划
    "目标对齐",       # 战略目标变更影响决策
    "关键KR对齐",     # 关键结果变更影响绩效
    "重要程度",       # 优先级变更影响资源分配
    "预计完成时间",   # 截止日期变更影响交付
    "完成进度"        # 进度变更影响项目状态
]
```

#### L2级 - 高风险列（6列）
```python
L2_COLUMNS = [
    "项目类型",       # 类型变更影响管理方式
    "具体计划内容",   # 内容变更需要语义分析
    "邓总指导登记",   # 高层指导需要特别关注
    "负责人",         # 责任人变更影响执行
    "协助人",         # 协作变更影响配合
    "监督人"          # 监督变更影响质量
]
```

#### L3级 - 一般风险列（6列）
```python
L3_COLUMNS = [
    "序号",           # 仅格式影响
    "完成链接",       # 参考链接
    "经理分析复盘",   # 分析记录
    "最新复盘时间",   # 记录性质
    "对上汇报",       # 信息同步
    "应用情况"        # 状态记录
]
```

---

## 第二部分：统一打分算法

### 📊 打分算法核心公式

#### 1. 基础分计算
```python
def calculate_base_score(column_level):
    """根据列级别返回基础分"""
    if column_level == "L1":
        return 0.8  # L1基础分
    elif column_level == "L2":
        return 0.5  # L2基础分
    else:  # L3
        return 0.2  # L3基础分
```

#### 2. 变更系数计算
```python
def calculate_change_factor(modification_count, total_rows):
    """计算变更系数"""
    if total_rows == 0:
        return 1.0

    ratio = modification_count / total_rows

    if ratio > 0.5:
        return 1.3  # 大量修改
    elif ratio > 0.3:
        return 1.2  # 中等修改
    elif ratio > 0.1:
        return 1.1  # 少量修改
    else:
        return 1.0  # 极少修改
```

#### 3. 列权重定义
```python
COLUMN_WEIGHTS = {
    # L1列权重
    "重要程度": 1.4,
    "任务发起时间": 1.3,
    "预计完成时间": 1.3,
    "完成进度": 1.1,
    # L2列权重
    "负责人": 1.2,
    "邓总指导登记": 1.15,
    "项目类型": 1.1,
    # 其他列默认权重1.0
}
```

#### 4. 最终分数计算
```python
def calculate_final_score(modification_count, total_rows, column_name):
    """计算最终分数"""
    # 无修改时返回背景值
    if modification_count == 0:
        return 0.05

    # 获取列级别
    column_level = get_column_level(column_name)

    # 计算各项因子
    base_score = calculate_base_score(column_level)
    change_factor = calculate_change_factor(modification_count, total_rows)
    column_weight = COLUMN_WEIGHTS.get(column_name, 1.0)

    # 计算最终分数
    score = base_score * change_factor * column_weight

    # 强制阈值（重要！）
    if column_level == "L1" and score > 0:
        score = max(0.8, score)  # L1强制最低0.8分
    elif column_level == "L2" and score > 0:
        score = max(0.6, score)  # L2强制最低0.6分

    return min(1.0, round(score, 2))
```

### 🎨 分数到颜色映射

| 分数范围 | 颜色 | RGB值 | 含义 |
|---------|------|-------|------|
| 0.8-1.0 | 红色 | #FF0000-#FFCCCC | 极高风险 |
| 0.6-0.8 | 橙色 | #FF8800-#FFCC88 | 高风险 |
| 0.4-0.6 | 黄色 | #FFFF00-#FFFFCC | 中风险 |
| 0.2-0.4 | 绿色 | #00FF00-#CCFFCC | 低风险 |
| 0.05-0.2 | 蓝色 | #0088FF-#CCE5FF | 极低风险 |
| 0-0.05 | 灰色 | #F0F0F0 | 无修改 |

---

## 第三部分：完整数据链路

### 🔄 数据流程架构

```
步骤1: CSV文件对比
├── baseline文件（基线版本）
├── current文件（当前版本）
└── 生成differences.json

步骤2: 详细打分（comparison_to_scoring_adapter.py）
├── extract_table_data() - 提取修改数据
├── _get_column_level() - 获取L1/L2/L3级别
├── _calculate_column_score() - 计算分数
└── 输出: table_data_list

步骤3: 综合打分生成（comprehensive_score_generator_v2.py）
├── 整合多表数据
├── 生成N×19矩阵
├── 计算统计信息
└── 输出: comprehensive_score_W{周数}_{时间戳}.json

步骤4: UI数据服务（final_heatmap_server.py）
├── 加载综合打分文件
├── 提供API端点
├── 数据格式转换
└── 输出: JSON API响应

步骤5: 前端展示（React组件）
├── 获取API数据
├── 渲染热力图
├── 用户交互处理
└── 输出: 可视化界面
```

### 📝 数据格式规范

#### CSV对比结果格式
```json
{
  "differences": [
    {
      "行号": 5,
      "列名": "负责人",
      "列索引": 8,
      "原值": "张三",
      "新值": "李四",
      "risk_level": "L2",
      "risk_score": 0.65
    }
  ]
}
```

#### 综合打分文件格式
```json
{
  "metadata": {
    "version": "2.0",
    "week": "W38",
    "timestamp": "2025-09-16T12:00:00",
    "total_params": 5200
  },
  "table_names": ["表1", "表2", ...],
  "column_names": [19个标准列],
  "heatmap_data": {
    "matrix": [[N×19的二维数组]]
  },
  "table_details": [...],
  "hover_data": {...},
  "statistics": {...}
}
```

---

## 第四部分：UI参数映射（合并自11规范）

### 🖥️ UI数据需求映射表

| UI需求参数 | JSON字段路径 | 数据来源 | 说明 |
|-----------|-------------|----------|------|
| 表名作为行名 | `table_names[]` | CSV文件名 | 热力图Y轴 |
| 列名 | `column_names[]` | 标准19列 | 热力图X轴 |
| 热力图数值 | `heatmap_data.matrix[][]` | 打分算法 | 格子颜色值 |
| 悬浮窗修改数 | `hover_data.data[].column_modifications[]` | 对比结果 | 每表每列修改数 |
| 表总修改数 | `statistics.table_modifications[]` | 统计计算 | 右侧统计栏 |
| 表总行数 | `statistics.table_row_counts[]` | CSV行数 | 一维图基础 |
| 修改行位置 | `table_details[].column_details[].modified_rows[]` | 对比结果 | 一维图详细 |
| Excel URL | `table_details[].excel_url` | 配置文件 | 点击跳转链接 |

### 🔌 API端点规范

#### 主数据端点：`/api/comprehensive_data`
```javascript
GET /api/comprehensive_data
Response: {
  success: true,
  data: {
    table_names: [...],
    column_names: [...],
    heatmap_data: {...},
    statistics: {...},
    table_details: [...]
  }
}
```

#### 详细数据端点：`/api/detailed_scores/<table_name>`
```javascript
GET /api/detailed_scores/表名
Response: {
  table_name: "表名",
  column_scores: {...},
  modified_rows: [...]
}
```

### 📊 UI组件参数流

```
综合打分JSON → Flask API → Fetch请求 → React State → Props传递 → 组件渲染
     ↓            ↓           ↓            ↓           ↓          ↓
  文件系统     HTTP服务    异步获取     状态管理    组件通信    界面展示
```

---

## 第五部分：🚨 服务器适配层实现规范（2025-09-17 新增）

### 关键数据结构转换

当API服务器加载综合打分文件并准备返回给前端时，**必须进行正确的数据结构转换**：

#### 1. tables数组构建（关键！）

```python
# ✅ 正确的tables数组构建
tables = []
if 'table_details' in data:
    for table in data['table_details']:
        # 从column_details聚合数据
        column_modifications = {}
        all_modified_rows = set()

        if 'column_details' in table:
            for col_detail in table['column_details']:
                col_name = col_detail.get('column_name', '')
                modified_rows = col_detail.get('modified_rows', [])

                # 关键：构建前端需要的数据结构
                column_modifications[col_name] = {
                    'modified_rows': modified_rows,  # 必须包含！
                    'modification_count': col_detail.get('modification_count', 0),
                    'modification_details': col_detail.get('modification_details', [])
                }
                all_modified_rows.update(modified_rows)

        # 构建前端期望的表格结构
        table_item = {
            'name': table.get('table_name', ''),
            'url': table.get('excel_url', ''),  # 注意：是excel_url不是table_url
            'risk_score': table.get('overall_risk_score', 0.05),
            'total_modifications': table.get('total_modifications', 0),
            'row_level_data': {
                'total_rows': table.get('total_rows', 100),
                'modified_rows': sorted(list(all_modified_rows)),
                'total_differences': table.get('total_modifications', 0),
                'column_modifications': column_modifications  # 关键数据！
            }
        }
        tables.append(table_item)
```

#### 2. 字段映射关系（避坑指南）

| 综合打分文件字段 | 前端API期望字段 | 常见错误 |
|---------------|--------------|---------|
| `table_details[].excel_url` | `tables[].url` | ❌ 使用table_url |
| `table_details[].overall_risk_score` | `tables[].risk_score` | ❌ 忽略overall前缀 |
| `table_details[].column_details` | `tables[].row_level_data.column_modifications` | ❌ 直接传递column_details |
| `table_details[].total_rows` | `tables[].row_level_data.total_rows` | ❌ 从错误层级取值 |

#### 3. hover_data转换

```python
# 如果hover_data格式不匹配前端期望
if 'hover_data' in response_data and 'data' in response_data['hover_data']:
    hover_items = response_data['hover_data']['data']
    converted_hover_data = []

    for item in hover_items:
        if 'column_details' in item:
            # 转换为column_modifications数组格式
            column_mods = []
            for col_detail in item['column_details']:
                mod_count = col_detail.get('modification_count', 0)
                column_mods.append(mod_count)

            converted_item = {
                'table_index': item.get('table_index', 0),
                'column_modifications': column_mods  # 前端期望的格式
            }
            converted_hover_data.append(converted_item)
```

#### 4. 数据完整性验证

适配层必须验证输出数据的完整性：

```python
def validate_adapted_data(response_data):
    """验证适配后的数据结构"""
    assert 'tables' in response_data, "缺少tables数组"

    for table in response_data['tables']:
        assert 'row_level_data' in table, f"表{table['name']}缺少row_level_data"
        row_data = table['row_level_data']

        assert 'column_modifications' in row_data, "缺少column_modifications"
        col_mods = row_data['column_modifications']

        assert len(col_mods) == 19, f"column_modifications应包含19列，实际{len(col_mods)}"

        for col_name, col_data in col_mods.items():
            assert 'modified_rows' in col_data, f"列{col_name}缺少modified_rows"
            assert isinstance(col_data['modified_rows'], list), "modified_rows必须是数组"
```

---

## 第六部分：零降级原则与错误处理

### 🚫 零降级原则

1. **不允许虚拟数据**：禁止使用random生成数据
2. **不允许降级回退**：缺失数据时必须报错，不能使用默认值
3. **不允许跳过验证**：每个环节都必须验证数据完整性
4. **不允许静默失败**：所有错误必须记录并通知

### ⚠️ 错误处理规范

```python
# 正确的错误处理
def load_comprehensive_data():
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
        validate_data_structure(data)  # 强制验证
        return data
    except FileNotFoundError:
        logger.error(f"综合打分文件不存在: {file_path}")
        raise  # 抛出错误，不降级
    except ValidationError as e:
        logger.error(f"数据验证失败: {e}")
        raise  # 抛出错误，不降级
```

### ✅ 数据验证检查点

1. **CSV对比阶段**：验证文件存在性、格式正确性
2. **详细打分阶段**：验证列名匹配、数值范围
3. **综合打分阶段**：验证矩阵维度、参数完整性
4. **API服务阶段**：验证数据加载、格式转换
5. **前端展示阶段**：验证数据接收、渲染正确性

---

## 第六部分：配置管理规范

### 🎯 配置文件统一管理

所有配置文件集中存放在 `/root/projects/tencent-doc-manager/config/` 目录：

```
config/
├── standard_columns.json    # 标准列定义（本规范的JSON版本）
├── scoring_algorithm.json   # 打分算法参数
├── risk_levels.json         # L1/L2/L3分级配置
├── column_weights.json      # 列权重配置
├── real_documents.json      # 文档配置
├── cookies.json            # Cookie存储
└── ui_config.json          # UI显示配置
```

### 📐 配置优先级

1. **规范定义** > 配置文件 > 代码硬编码
2. 本规范是最高优先级的权威定义
3. 配置文件用于运行时参数调整
4. 代码中不应硬编码任何可配置项

---

## 第七部分：实施指南

### 🔧 代码同步要求

1. **standard_columns_config.py** - 必须与本规范完全一致
2. **comparison_to_scoring_adapter.py** - L1/L2/L3分类必须同步
3. **comprehensive_score_generator_v2.py** - 打分算法必须统一
4. **final_heatmap_server.py** - API数据格式必须规范

### 📝 文档维护

- 本规范是唯一的权威定义文档
- 任何列定义、打分算法的修改必须先更新本规范
- 代码实现必须严格遵循本规范

### 🔍 验证工具

使用 `/root/projects/tencent-doc-manager/validate_ui_data_mapping.py` 验证实现符合性

```bash
python3 validate_ui_data_mapping.py
```

---

## 附录：变更历史

| 版本 | 日期 | 变更内容 |
|------|------|---------|
| 4.0 | 2025-09-16 | 统一规范，合并UI参数，更新标准列 |
| 3.0 | 2025-09-16 | 修复降级问题 |
| 2.0 | 2025-09-13 | 添加L1/L2/L3分级 |
| 1.0 | 2025-09-10 | 初始版本 |

---

**维护说明**: 本规范是系统的核心技术文档，任何修改需要经过严格评审。
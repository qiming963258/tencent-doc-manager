# 热力图算法渲染实现技术规格

## 文档版本
- 版本：4.0（高风险深红优化版）
- 创建日期：2025-09-11
- 更新日期：2025-09-18
- 作者：Claude Code
- 状态：已实现并部署（8089生产环境）
- 最新更新：修复高风险值显示为深红色而非白色

## 📌 本规范职责
- **包含**：热力图渲染算法、色彩映射、插值算法、聚类优化
- **不包含**：打分算法（见10规范）、数据源管理（见10规范）

---

## 1. 系统概述

### 1.1 基本信息
- **生产端口**：8089
- **测试端口**：8090
- **技术栈**：Canvas 2D + WebGL渲染
- **热力图矩阵**：N×19（N为动态表格数量）

### 1.2 核心功能
实现从数值矩阵到连续热力场可视化的专业级渲染，采用多层算法组合实现热成像效果。

---

## 2. 核心渲染算法

### 2.1 IDW反距离加权插值算法

#### 2.1.1 算法参数
```javascript
powerParameter = 2.0;  // 功率参数（距离平方反比）
maxInfluenceDistance = cellSize * 3;  // 最大影响距离（96像素）
```

#### 2.1.2 核心公式
```javascript
// IDW插值核心实现
for (const source of heatSources) {
  const distance = Math.sqrt((x - source.x)² + (y - source.y)²);

  if (distance < 1) {
    // 极近距离直接使用源值
    weightedSum = source.intensity;
    weightSum = 1;
    break;
  }

  if (distance <= maxInfluenceDistance) {
    const weight = 1 / Math.pow(distance, powerParameter);
    weightedSum += source.intensity * weight;
    weightSum += weight;
  }
}

finalIntensity = weightedSum / weightSum;
```

#### 2.1.3 边界处理策略
- **极近距离**（< 1px）：直接使用源点强度值
- **影响范围内**（≤ 3*cellSize）：标准IDW插值
- **影响范围外**：指数衰减补偿

### 2.2 FLIR热成像色彩映射

#### 2.2.1 8段精确色彩过渡
```javascript
// 热成像颜色映射表
const colorStops = [
  { value: 0.000, color: [0, 0, 0] },       // 黑色
  { value: 0.125, color: [0, 0, 139] },     // 深蓝
  { value: 0.250, color: [0, 0, 255] },     // 纯蓝
  { value: 0.375, color: [100, 255, 255] }, // 青色
  { value: 0.500, color: [0, 255, 55] },    // 绿色
  { value: 0.625, color: [255, 255, 0] },   // 黄色
  { value: 0.750, color: [255, 128, 0] },   // 橙色
  { value: 0.875, color: [255, 0, 0] },     // 红色
  { value: 1.000, color: [255, 255, 255] }  // 白色（极值）
];
```

#### 2.2.2 线性插值计算
```javascript
function interpolateColor(value) {
  // 找到相邻的两个颜色停靠点
  for (let i = 0; i < colorStops.length - 1; i++) {
    if (value <= colorStops[i + 1].value) {
      const lower = colorStops[i];
      const upper = colorStops[i + 1];

      // 计算插值比例
      const range = upper.value - lower.value;
      const t = (value - lower.value) / range;

      // RGB线性插值
      const r = Math.floor(lower.color[0] + t * (upper.color[0] - lower.color[0]));
      const g = Math.floor(lower.color[1] + t * (upper.color[1] - lower.color[1]));
      const b = Math.floor(lower.color[2] + t * (upper.color[2] - lower.color[2]));

      return `rgb(${r}, ${g}, ${b})`;
    }
  }
}
```

### 2.3 热扩散算法

#### 2.3.1 算法参数
```python
iterations = 3        # 迭代次数（轻度扩散）
diffusion_rate = 0.08 # 扩散率（保留真实热点）
```

#### 2.3.2 5×5邻域扩散
```python
# 扩散核（高斯权重）
kernel = [
  [0.003, 0.013, 0.022, 0.013, 0.003],
  [0.013, 0.059, 0.097, 0.059, 0.013],
  [0.022, 0.097, 0.159, 0.097, 0.022],
  [0.013, 0.059, 0.097, 0.059, 0.013],
  [0.003, 0.013, 0.022, 0.013, 0.003]
]
```

#### 2.3.3 扩散计算
```python
def apply_heat_diffusion(matrix, iterations=3):
    """应用热扩散算法"""
    result = matrix.copy()

    for _ in range(iterations):
        temp = np.zeros_like(result)

        for i in range(2, rows-2):
            for j in range(2, cols-2):
                # 应用5×5卷积核
                weighted_sum = 0
                for ki in range(5):
                    for kj in range(5):
                        weighted_sum += result[i-2+ki, j-2+kj] * kernel[ki][kj]

                # 混合原值和扩散值
                temp[i, j] = result[i, j] * (1 - diffusion_rate) + weighted_sum * diffusion_rate

        result = temp

    return result
```

---

## 3. 高级聚类优化算法

### 3.1 Getis-Ord Gi*热点检测

#### 3.1.1 算法原理
识别统计显著的空间聚集模式（热点和冷点）

#### 3.1.2 Z-score计算
```python
def calculate_getis_ord(matrix):
    """计算Getis-Ord Gi*统计量"""
    n = matrix.size
    mean = np.mean(matrix)
    std = np.std(matrix)

    z_scores = np.zeros_like(matrix)

    for i in range(rows):
        for j in range(cols):
            # 计算局部和
            neighbors = get_neighbors(i, j, radius=2)
            local_sum = sum(matrix[ni, nj] for ni, nj in neighbors)

            # 计算Z-score
            expected = mean * len(neighbors)
            variance = std * np.sqrt(len(neighbors))
            z_scores[i, j] = (local_sum - expected) / variance

    return z_scores
```

#### 3.1.3 显著性判定
```python
# p < 0.05的显著性阈值
if abs(z_score) > 1.96:
    if z_score > 0:
        # 显著热点
        classification = "HOT_SPOT"
    else:
        # 显著冷点
        classification = "COLD_SPOT"
```

### 3.2 SpectralCoclustering双聚类

#### 3.2.1 算法目标
同时优化行和列的排序，使相似的行/列聚集在一起

#### 3.2.2 实现步骤
```python
def apply_spectral_coclustering(matrix):
    """应用谱双聚类算法"""
    from sklearn.cluster.bicluster import SpectralCoclustering

    # 创建模型
    model = SpectralCoclustering(
        n_clusters=(3, 3),  # 3×3聚类网格
        method='bistochastic',
        n_init=10,
        random_state=42
    )

    # 拟合模型
    model.fit(matrix)

    # 获取行列排序
    row_order = np.argsort(model.row_labels_)
    col_order = np.argsort(model.column_labels_)

    return row_order, col_order
```

### 3.3 Cuthill-McKee带宽优化

#### 3.3.1 算法目标
最小化矩阵带宽，提高空间连续性

#### 3.3.2 实现
```python
def cuthill_mckee_ordering(adjacency_matrix):
    """Cuthill-McKee算法优化矩阵带宽"""
    from scipy.sparse.csgraph import reverse_cuthill_mckee

    # 应用RCM算法
    perm = reverse_cuthill_mckee(adjacency_matrix)

    return perm
```

---

## 4. Canvas渲染优化技术

### 4.1 双缓冲渲染
```javascript
// 创建离屏画布
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d');

// 离屏渲染
renderHeatmap(offscreenCtx);

// 一次性绘制到主画布
mainCtx.drawImage(offscreenCanvas, 0, 0);
```

### 4.2 图像数据直接操作
```javascript
// 直接操作像素数据
const imageData = ctx.createImageData(width, height);
const data = imageData.data;

for (let i = 0; i < data.length; i += 4) {
  const intensity = calculateIntensity(i / 4);
  const color = getColorForIntensity(intensity);

  data[i] = color.r;     // Red
  data[i + 1] = color.g; // Green
  data[i + 2] = color.b; // Blue
  data[i + 3] = 255;     // Alpha
}

ctx.putImageData(imageData, 0, 0);
```

### 4.3 渐变缓存
```javascript
// 预生成渐变色谱
const gradientCanvas = createGradientCanvas();
const gradientCtx = gradientCanvas.getContext('2d');
const gradient = gradientCtx.createLinearGradient(0, 0, 256, 0);

// 添加色标
colorStops.forEach(stop => {
  gradient.addColorStop(stop.value, stop.color);
});

// 缓存渐变查找表
const colorLUT = new Uint8ClampedArray(256 * 4);
const imageData = gradientCtx.getImageData(0, 0, 256, 1);
colorLUT.set(imageData.data);
```

---

## 5. 性能优化策略

### 5.1 分块渲染
- 将大矩阵分成小块
- 使用requestAnimationFrame逐块渲染
- 避免长时间阻塞主线程

### 5.2 Web Workers并行计算
```javascript
// 主线程
const worker = new Worker('heatmap-worker.js');
worker.postMessage({
  matrix: matrixData,
  params: renderParams
});

worker.onmessage = (e) => {
  const imageData = e.data;
  ctx.putImageData(imageData, 0, 0);
};
```

### 5.3 WebGL加速（可选）
- 使用WebGL着色器进行并行插值计算
- GPU加速颜色映射
- 适合大规模数据渲染

---

## 6. 渲染参数配置

### 6.1 可调参数
```javascript
const renderConfig = {
  // IDW插值
  idw: {
    power: 2.0,
    maxDistance: 96,
    minDistance: 1
  },

  // 热扩散
  diffusion: {
    enabled: true,
    iterations: 3,
    rate: 0.08
  },

  // 色彩映射
  colorMap: {
    type: 'FLIR',  // FLIR | JET | HSV | GRAYSCALE
    interpolation: 'linear'  // linear | cubic
  },

  // 性能
  performance: {
    useWebWorkers: true,
    useWebGL: false,
    blockSize: 100
  }
};
```

### 6.2 自适应参数
系统根据数据特征自动调整：
- 稀疏数据：增加扩散迭代次数
- 密集数据：减少插值范围
- 大矩阵：启用分块渲染

---

## 7. 渲染质量保证

### 7.1 视觉一致性
- 确保相同数值产生相同颜色
- 颜色过渡平滑无突变
- 边界处理自然

### 7.2 数值准确性
- 插值结果可验证
- 颜色映射可逆
- 保留原始热点特征

### 7.3 性能指标
- 30×19矩阵渲染 < 100ms
- 60fps交互响应
- 内存占用 < 50MB

---

## 附录：参考实现

### A. 完整渲染流程
```javascript
function renderHeatmap(matrix, canvas) {
  const ctx = canvas.getContext('2d');

  // 1. 数据预处理
  const normalizedMatrix = normalizeData(matrix);

  // 2. 应用聚类优化
  const optimizedMatrix = applyClusteringOptimization(normalizedMatrix);

  // 3. 热扩散处理
  const diffusedMatrix = applyHeatDiffusion(optimizedMatrix);

  // 4. IDW插值
  const interpolatedData = applyIDWInterpolation(diffusedMatrix);

  // 5. 颜色映射
  const imageData = mapToColors(interpolatedData);

  // 6. 渲染到画布
  ctx.putImageData(imageData, 0, 0);
}
```

### B. 颜色查找表生成
```javascript
function generateColorLUT() {
  const lut = new Array(256);

  for (let i = 0; i < 256; i++) {
    const value = i / 255;
    lut[i] = interpolateColor(value);
  }

  return lut;
}
```

---

**维护说明**: 本规范专注于渲染算法实现，与10规范的打分逻辑完全解耦。
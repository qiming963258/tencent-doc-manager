# 前端组件集成规格书

## 1. 组件架构总览

### 1.1 基于现有React组件的扩展架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     前端组件集成架构 (React 18.x + Tailwind CSS)              │
├─────────────────────────────────────────────────────────────────────────────┤
│  主应用容器 (App.jsx)                                                        │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ 路由管理         │  │ 全局状态管理     │  │ API服务层        │              │
│  │ React Router     │  │ Context API     │  │ axios/fetch     │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────────────────────────┤
│  核心可视化组件层                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ AdvancedSortedHeatmap.jsx (1381行 - 现有核心组件)                        │ │
│  │ ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐          │ │
│  │ │ 热力图矩阵渲染   │  │ 高斯平滑算法     │  │ 颜色映射系统     │          │ │
│  │ │ - 30×19数据矩阵  │  │ - 科学热力图     │  │ - 5级色彩分段    │          │ │
│  │ │ - Canvas绘制     │  │ - 热点聚集       │  │ - 血红色高风险   │          │ │
│  │ └─────────────────┘  └─────────────────┘  └─────────────────┘          │ │
│  │ ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐          │ │
│  │ │ 悬浮提示系统     │  │ 交互控制面板     │  │ 统计分析面板     │          │ │
│  │ │ - 跟随鼠标       │  │ - 网格线切换     │  │ - 实时统计       │          │ │
│  │ │ - 详细信息       │  │ - 等高线显示     │  │ - 风险分级       │          │ │
│  │ └─────────────────┘  └─────────────────┘  └─────────────────┘          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  功能扩展组件层                                                               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ 监控设置面板     │  │ 表格内分布图     │  │ 批量操作面板     │              │
│  │ SettingsModal    │  │TableModification │  │ BatchOperations │              │
│  │ - 表格链接导入   │  │ - 修改分布模式   │  │ - 批量下载       │              │
│  │ - Cookie管理     │  │ - 行号标尺       │  │ - 批量上传       │              │
│  │ - 监控参数配置   │  │ - 风险状态点     │  │ - 进度跟踪       │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────────────────────────┤
│  数据适配和工具组件层                                                          │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ 数据转换器       │  │ 参数验证器       │  │ 错误边界组件     │              │
│  │ DataTransformer │  │ ParameterValidator│ │ ErrorBoundary   │              │
│  │ - 5200+参数处理  │  │ - 输入校验       │  │ - 错误捕获       │              │
│  │ - 矩阵数据转换   │  │ - 类型检查       │  │ - 优雅降级       │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 组件依赖关系图

```
                      App.jsx
                         │
                         ▼
               AdvancedSortedHeatmap.jsx
                    │    │    │
          ┌─────────┤    │    └─────────┐
          ▼         ▼    ▼              ▼
    SettingsModal  │ HeatmapCore  TableModificationChart
          │        │      │              │
          ▼        ▼      ▼              ▼
    LinkImporter  ColorMapper  DistributionAnalyzer
                     │              │
                     ▼              ▼
               GaussianSmooth  PatternRecognizer
```

## 2. 核心组件详细规格

### 2.1 AdvancedSortedHeatmap.jsx 扩展规格

#### 2.1.1 现有组件分析 (基于1381行代码)
```javascript
// 现有组件核心功能结构
const AdvancedSortedHeatmap = () => {
  // 状态管理 (现有)
  const [hoveredCell, setHoveredCell] = useState(null);
  const [showGrid, setShowGrid] = useState(false);
  const [showContours, setShowContours] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  
  // 数据生成和处理 (现有)
  const { data: heatData, tableNames, columnNames, tables } = useMemo(
    () => generateSortedHeatData(), []
  );
  const { patterns: modificationPatterns, globalMaxRows } = useMemo(
    () => generateTableModificationPatterns(tables, columnNames), 
    [tables, columnNames]
  );
  
  // 统计计算 (现有)
  const meaningfulStats = useMemo(() => {
    // 实时计算L1/L2/L3修改统计
    return calculateMeaningfulStatistics(heatData, tables, columnNames);
  }, [heatData, tables, columnNames]);
};
```

#### 2.1.2 集成扩展点设计
```javascript
// 扩展的组件接口设计
const EnhancedAdvancedSortedHeatmap = ({
  // 新增props用于API数据集成
  apiDataSource = null,        // API数据源配置
  realTimeUpdates = false,     // 实时更新开关
  userCredentials = null,      // 用户认证信息
  customParameters = {},       // 5200+自定义参数
  onCellInteraction = null,    // 单元格交互回调
  onBatchOperation = null,     // 批量操作回调
  
  // 现有props保持兼容
  initialTableCount = 30,
  initialColumnCount = 19,
  enableGaussianSmooth = true
}) => {
  // 扩展的状态管理
  const [realTimeData, setRealTimeData] = useState(null);
  const [wsConnection, setWsConnection] = useState(null);
  const [batchJobStatus, setBatchJobStatus] = useState({});
  const [parameterOverrides, setParameterOverrides] = useState({});
  
  // API数据集成钩子
  const { 
    heatmapData, 
    isLoading, 
    error, 
    refetch 
  } = useHeatmapData(apiDataSource, realTimeUpdates);
  
  // 实时WebSocket连接
  useEffect(() => {
    if (realTimeUpdates && userCredentials) {
      const ws = new WebSocket(`ws://localhost:5000/ws/heatmap/${userCredentials.userId}`);
      ws.onmessage = handleRealTimeUpdate;
      setWsConnection(ws);
      
      return () => ws.close();
    }
  }, [realTimeUpdates, userCredentials]);
  
  const handleRealTimeUpdate = (event) => {
    const update = JSON.parse(event.data);
    if (update.type === 'heatmap_data_update') {
      setRealTimeData(update.data);
    } else if (update.type === 'batch_job_progress') {
      setBatchJobStatus(prev => ({
        ...prev,
        [update.jobId]: update.status
      }));
    }
  };
  
  // 参数处理和验证
  const processedParameters = useMemo(() => {
    return ParameterProcessor.process({
      base: customParameters,
      overrides: parameterOverrides,
      validation: ParameterValidator.rules
    });
  }, [customParameters, parameterOverrides]);
};
```

#### 2.1.3 高级交互功能扩展
```javascript
// 扩展的事件处理系统
const EnhancedInteractionHandlers = {
  // 单元格深度交互
  handleCellDeepDive: (cellData) => {
    return {
      showDetailModal: true,
      detailData: {
        tableInfo: cellData.table,
        columnAnalysis: cellData.column,
        modificationHistory: cellData.modifications,
        aiAnalysisResults: cellData.aiAnalysis,
        riskAssessment: cellData.riskAssessment
      }
    };
  },
  
  // 批量选择和操作
  handleBatchCellSelection: (selectedCells) => {
    return {
      selectedCount: selectedCells.length,
      availableOperations: [
        'batch_ai_analysis',
        'batch_risk_reassessment', 
        'export_selection',
        'create_monitoring_rule'
      ],
      estimatedProcessingTime: calculateBatchProcessingTime(selectedCells)
    };
  },
  
  // 实时筛选和搜索
  handleAdvancedFiltering: (filterCriteria) => {
    return {
      filteredData: applyAdvancedFilters(heatmapData, filterCriteria),
      highlightedCells: identifyMatchingCells(filterCriteria),
      filterSummary: generateFilterSummary(filterCriteria)
    };
  }
};
```

### 2.2 SettingsModal.jsx 扩展规格

#### 2.2.1 现有功能扩展
```javascript
// 基于现有SettingsModal扩展的完整配置面板
const EnhancedSettingsModal = ({ isOpen, onClose, userCredentials }) => {
  // 扩展的状态管理
  const [activeTab, setActiveTab] = useState('links');
  const [configurationState, setConfigurationState] = useState({
    links: { imported: [], failed: [], pending: [] },
    authentication: { cookies: '', status: 'unverified' },
    monitoring: { frequency: '5min', alertLevel: 'L1', notifications: true },
    parameters: { custom: {}, overrides: {}, validation: {} },
    ai: { provider: 'claude', apiKey: '', threshold: 0.7 },
    visualization: { theme: 'professional', density: 'normal', animations: true }
  });
  
  return (
    <div className="settings-modal-container">
      {/* 扩展的标签页导航 */}
      <div className="tabs-navigation">
        <TabButton id="links" active={activeTab === 'links'} onClick={setActiveTab}>
          表格链接管理
        </TabButton>
        <TabButton id="auth" active={activeTab === 'auth'} onClick={setActiveTab}>
          认证配置
        </TabButton>
        <TabButton id="monitoring" active={activeTab === 'monitoring'} onClick={setActiveTab}>
          监控设置
        </TabButton>
        <TabButton id="parameters" active={activeTab === 'parameters'} onClick={setActiveTab}>
          参数配置
        </TabButton>
        <TabButton id="ai" active={activeTab === 'ai'} onClick={setActiveTab}>
          AI设置
        </TabButton>
        <TabButton id="visualization" active={activeTab === 'visualization'} onClick={setActiveTab}>
          可视化配置
        </TabButton>
      </div>
      
      {/* 标签页内容 */}
      <div className="tab-content">
        {activeTab === 'links' && <LinkManagementPanel />}
        {activeTab === 'auth' && <AuthenticationPanel />}
        {activeTab === 'monitoring' && <MonitoringConfigPanel />}
        {activeTab === 'parameters' && <ParameterConfigPanel />}
        {activeTab === 'ai' && <AIConfigurationPanel />}
        {activeTab === 'visualization' && <VisualizationConfigPanel />}
      </div>
    </div>
  );
};
```

#### 2.2.2 表格链接管理面板
```javascript
const LinkManagementPanel = () => {
  const [linkInput, setLinkInput] = useState('');
  const [importProgress, setImportProgress] = useState(null);
  const [validationResults, setValidationResults] = useState([]);
  
  const handleBatchLinkImport = async (linkText) => {
    const links = parseTencentDocLinks(linkText);
    setImportProgress({ total: links.length, processed: 0, failed: 0 });
    
    const results = [];
    for (const link of links) {
      try {
        const validation = await validateTencentDocLink(link);
        results.push({
          url: link.url,
          name: link.name,
          status: 'valid',
          tableInfo: validation.tableInfo
        });
        setImportProgress(prev => ({ ...prev, processed: prev.processed + 1 }));
      } catch (error) {
        results.push({
          url: link.url, 
          name: link.name,
          status: 'invalid',
          error: error.message
        });
        setImportProgress(prev => ({ 
          ...prev, 
          processed: prev.processed + 1,
          failed: prev.failed + 1 
        }));
      }
    }
    
    setValidationResults(results);
    setImportProgress(null);
  };
  
  return (
    <div className="link-management-panel">
      <div className="link-input-section">
        <label>批量导入腾讯文档链接</label>
        <textarea
          value={linkInput}
          onChange={(e) => setLinkInput(e.target.value)}
          placeholder="请粘贴腾讯文档链接，支持以下格式：&#10;【腾讯文档】项目管理表&#10;https://docs.qq.com/sheet/xxx&#10;&#10;或直接粘贴多个链接，每行一个"
          rows={8}
          className="link-input-textarea"
        />
        <div className="input-actions">
          <button onClick={() => handleBatchLinkImport(linkInput)}>
            验证并导入链接
          </button>
          <span className="link-count">
            {parseTencentDocLinks(linkInput).length} 个链接待处理
          </span>
        </div>
      </div>
      
      {importProgress && (
        <div className="import-progress">
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ width: `${(importProgress.processed / importProgress.total) * 100}%` }}
            />
          </div>
          <div className="progress-text">
            处理中: {importProgress.processed}/{importProgress.total} 
            {importProgress.failed > 0 && `(失败: ${importProgress.failed})`}
          </div>
        </div>
      )}
      
      {validationResults.length > 0 && (
        <div className="validation-results">
          <h4>链接验证结果</h4>
          <div className="results-list">
            {validationResults.map((result, index) => (
              <div key={index} className={`result-item ${result.status}`}>
                <div className="result-info">
                  <strong>{result.name}</strong>
                  <span className="result-url">{result.url}</span>
                </div>
                <div className="result-status">
                  {result.status === 'valid' ? (
                    <span className="status-valid">✓ 有效</span>
                  ) : (
                    <span className="status-invalid">✗ {result.error}</span>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### 2.3 TableModificationChart.jsx 扩展规格

#### 2.3.1 现有组件增强
```javascript
// 基于现有TableModificationChart扩展的高级分布图
const EnhancedTableModificationChart = ({
  pattern,
  columnName,
  isHovered = false,
  allPatterns = [],
  globalMaxRows = 50,
  maxWidth = 300,
  tableData = null,
  // 新增扩展props
  enableInteractiveMode = false,
  showAdvancedMetrics = false,
  onPatternClick = null,
  customColorScheme = null
}) => {
  // 扩展的状态管理
  const [interactiveMode, setInteractiveMode] = useState(enableInteractiveMode);
  const [selectedTimeRange, setSelectedTimeRange] = useState('24h');
  const [metricOverlay, setMetricOverlay] = useState(null);
  
  // 高级模式渲染
  if (interactiveMode) {
    return (
      <div className="enhanced-modification-chart">
        {/* 时间范围选择器 */}
        <div className="time-range-selector">
          <button 
            className={selectedTimeRange === '1h' ? 'active' : ''}
            onClick={() => setSelectedTimeRange('1h')}
          >
            1小时
          </button>
          <button 
            className={selectedTimeRange === '24h' ? 'active' : ''}
            onClick={() => setSelectedTimeRange('24h')}
          >
            24小时
          </button>
          <button 
            className={selectedTimeRange === '7d' ? 'active' : ''}
            onClick={() => setSelectedTimeRange('7d')}
          >
            7天
          </button>
        </div>
        
        {/* 高级指标覆盖层 */}
        {showAdvancedMetrics && (
          <div className="metrics-overlay">
            <div className="metric-item">
              <span>修改频率</span>
              <span>{calculateModificationFrequency(pattern, selectedTimeRange)}</span>
            </div>
            <div className="metric-item">
              <span>风险趋势</span>
              <span className={`trend ${getRiskTrend(pattern)}`}>
                {getRiskTrend(pattern)}
              </span>
            </div>
            <div className="metric-item">
              <span>影响范围</span>
              <span>{calculateImpactScope(pattern)}</span>
            </div>
          </div>
        )}
        
        {/* 交互式分布图 */}
        <div 
          className="interactive-distribution"
          onClick={() => onPatternClick && onPatternClick(pattern)}
        >
          {renderInteractiveDistribution(pattern, customColorScheme)}
        </div>
      </div>
    );
  }
  
  // 保持原有的静态/悬浮模式兼容性
  return renderOriginalChart(pattern, isHovered);
};
```

## 3. UI参数集成系统

### 3.1 5200+参数管理架构

#### 3.1.1 参数分层管理
```javascript
// 基于refer/ui参数.txt的参数体系实现
class UIParameterManager {
  constructor() {
    this.parameterCategories = {
      // 第一层: 表格基础数据 (240个参数)
      tableBasicData: new ParameterCategory('表格基础数据', {
        totalCount: 30,
        fieldsPerTable: 8,
        validationRules: TableBasicDataValidator
      }),
      
      // 第二层: 热力图核心数据 (570个数据点)
      heatmapCoreData: new ParameterCategory('热力图核心数据', {
        matrixSize: [30, 19],
        dataPoints: 570,
        validationRules: HeatmapDataValidator
      }),
      
      // 第三层: 修改分布模式 (4560个参数)
      modificationPatterns: new ParameterCategory('修改分布模式', {
        tablesCount: 30,
        columnsPerTable: 19,
        avgModificationsPerColumn: 8,
        validationRules: ModificationPatternValidator
      }),
      
      // 第四层: 视觉配置参数 (150个参数)
      visualConfiguration: new ParameterCategory('视觉配置', {
        layoutParams: 10,
        colorMappingParams: 15,
        interactionParams: 10,
        validationRules: VisualConfigValidator
      }),
      
      // 第五层: 其他系统参数 (180个参数)
      systemConfiguration: new ParameterCategory('系统配置', {
        performanceParams: 8,
        securityParams: 12,
        integrationParams: 20,
        validationRules: SystemConfigValidator
      })
    };
  }
  
  // 参数验证和处理
  processParameters(inputParameters) {
    const processedParams = {};
    const validationErrors = [];
    
    for (const [category, categoryManager] of Object.entries(this.parameterCategories)) {
      try {
        const categoryParams = inputParameters[category] || {};
        const processed = categoryManager.process(categoryParams);
        processedParams[category] = processed;
      } catch (error) {
        validationErrors.push({
          category,
          error: error.message,
          suggestion: categoryManager.getErrorSuggestion(error)
        });
      }
    }
    
    if (validationErrors.length > 0) {
      throw new ParameterValidationError(validationErrors);
    }
    
    return {
      processedParams,
      parameterCount: this.getTotalParameterCount(processedParams),
      validationSummary: this.generateValidationSummary(processedParams)
    };
  }
}
```

#### 3.1.2 参数绑定和响应式更新
```javascript
// React钩子用于参数管理
const useUIParameters = (initialParameters = {}) => {
  const [parameters, setParameters] = useState(initialParameters);
  const [validationState, setValidationState] = useState({});
  const [parameterHistory, setParameterHistory] = useState([]);
  
  const parameterManager = useMemo(() => new UIParameterManager(), []);
  
  // 参数更新处理
  const updateParameters = useCallback((updates, category = null) => {
    setParameters(prev => {
      const newParams = category 
        ? { ...prev, [category]: { ...prev[category], ...updates } }
        : { ...prev, ...updates };
      
      // 记录参数变更历史
      setParameterHistory(history => [...history, {
        timestamp: Date.now(),
        changes: updates,
        category
      }]);
      
      // 异步验证参数
      setTimeout(() => {
        try {
          const processed = parameterManager.processParameters(newParams);
          setValidationState({ 
            isValid: true, 
            errors: [],
            summary: processed.validationSummary
          });
        } catch (error) {
          setValidationState({
            isValid: false,
            errors: error.validationErrors,
            summary: null
          });
        }
      }, 0);
      
      return newParams;
    });
  }, [parameterManager]);
  
  // 批量参数导入
  const importParameters = useCallback(async (parameterSource) => {
    if (typeof parameterSource === 'string') {
      // 从JSON字符串导入
      const imported = JSON.parse(parameterSource);
      updateParameters(imported);
    } else if (parameterSource instanceof File) {
      // 从文件导入
      const text = await parameterSource.text();
      const imported = JSON.parse(text);
      updateParameters(imported);
    } else {
      // 直接对象导入
      updateParameters(parameterSource);
    }
  }, [updateParameters]);
  
  // 参数导出
  const exportParameters = useCallback((format = 'json') => {
    const exportData = {
      parameters,
      metadata: {
        exportTime: new Date().toISOString(),
        parameterCount: parameterManager.getTotalParameterCount(parameters),
        version: '1.0'
      }
    };
    
    if (format === 'json') {
      return JSON.stringify(exportData, null, 2);
    } else if (format === 'blob') {
      return new Blob([JSON.stringify(exportData, null, 2)], {
        type: 'application/json'
      });
    }
  }, [parameters, parameterManager]);
  
  return {
    parameters,
    validationState,
    parameterHistory,
    updateParameters,
    importParameters,
    exportParameters
  };
};
```

### 3.2 参数配置界面组件

#### 3.2.1 参数配置面板
```javascript
const ParameterConfigurationPanel = () => {
  const {
    parameters,
    validationState,
    updateParameters,
    importParameters,
    exportParameters
  } = useUIParameters();
  
  const [activeCategory, setActiveCategory] = useState('tableBasicData');
  const [searchQuery, setSearchQuery] = useState('');
  const [unsavedChanges, setUnsavedChanges] = useState(false);
  
  return (
    <div className="parameter-config-panel">
      {/* 参数类别导航 */}
      <div className="parameter-categories">
        <div className="category-nav">
          <button 
            className={activeCategory === 'tableBasicData' ? 'active' : ''}
            onClick={() => setActiveCategory('tableBasicData')}
          >
            表格基础数据 <span className="param-count">(240)</span>
          </button>
          <button 
            className={activeCategory === 'heatmapCoreData' ? 'active' : ''}
            onClick={() => setActiveCategory('heatmapCoreData')}
          >
            热力图核心数据 <span className="param-count">(570)</span>
          </button>
          <button 
            className={activeCategory === 'modificationPatterns' ? 'active' : ''}
            onClick={() => setActiveCategory('modificationPatterns')}
          >
            修改分布模式 <span className="param-count">(4560)</span>
          </button>
          <button 
            className={activeCategory === 'visualConfiguration' ? 'active' : ''}
            onClick={() => setActiveCategory('visualConfiguration')}
          >
            视觉配置 <span className="param-count">(150)</span>
          </button>
        </div>
        
        {/* 参数搜索 */}
        <div className="parameter-search">
          <input
            type="text"
            placeholder="搜索参数..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="search-input"
          />
        </div>
      </div>
      
      {/* 参数编辑区域 */}
      <div className="parameter-editor">
        {activeCategory === 'tableBasicData' && (
          <TableBasicDataEditor 
            parameters={parameters.tableBasicData || {}}
            onUpdate={(updates) => updateParameters(updates, 'tableBasicData')}
            searchQuery={searchQuery}
          />
        )}
        
        {activeCategory === 'heatmapCoreData' && (
          <HeatmapCoreDataEditor
            parameters={parameters.heatmapCoreData || {}}
            onUpdate={(updates) => updateParameters(updates, 'heatmapCoreData')}
            searchQuery={searchQuery}
          />
        )}
        
        {/* 其他类别编辑器... */}
      </div>
      
      {/* 参数状态和操作 */}
      <div className="parameter-actions">
        <div className="validation-status">
          {validationState.isValid ? (
            <span className="status-valid">✓ 参数配置有效</span>
          ) : (
            <span className="status-invalid">
              ✗ {validationState.errors?.length || 0} 个配置错误
            </span>
          )}
        </div>
        
        <div className="action-buttons">
          <button onClick={() => importParameters()}>
            导入配置
          </button>
          <button onClick={() => {
            const blob = exportParameters('blob');
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `参数配置_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
          }}>
            导出配置
          </button>
          <button 
            className="primary"
            disabled={!validationState.isValid}
            onClick={() => applyParameters(parameters)}
          >
            应用配置
          </button>
        </div>
      </div>
    </div>
  );
};
```

## 4. 实时数据集成

### 4.1 WebSocket实时通信

#### 4.1.1 实时数据连接管理
```javascript
// 实时数据管理钩子
const useRealTimeHeatmapData = (userCredentials) => {
  const [connection, setConnection] = useState(null);
  const [realTimeData, setRealTimeData] = useState(null);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [lastUpdate, setLastUpdate] = useState(null);
  
  useEffect(() => {
    if (userCredentials) {
      const ws = new WebSocket(
        `ws://localhost:5000/ws/heatmap/${userCredentials.userId}`
      );
      
      ws.onopen = () => {
        setConnectionStatus('connected');
        console.log('实时数据连接已建立');
      };
      
      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleRealTimeMessage(message);
      };
      
      ws.onclose = () => {
        setConnectionStatus('disconnected');
        // 自动重连逻辑
        setTimeout(() => {
          if (userCredentials) {
            // 重新连接
          }
        }, 5000);
      };
      
      ws.onerror = (error) => {
        setConnectionStatus('error');
        console.error('WebSocket连接错误:', error);
      };
      
      setConnection(ws);
      
      return () => {
        ws.close();
      };
    }
  }, [userCredentials]);
  
  const handleRealTimeMessage = (message) => {
    switch (message.type) {
      case 'heatmap_data_update':
        setRealTimeData(message.data);
        setLastUpdate(new Date());
        break;
      case 'table_modification':
        handleTableModificationUpdate(message);
        break;
      case 'batch_job_progress':
        handleBatchJobUpdate(message);
        break;
      case 'ai_analysis_complete':
        handleAIAnalysisUpdate(message);
        break;
    }
  };
  
  return {
    realTimeData,
    connectionStatus,
    lastUpdate,
    subscribe: (eventType) => {
      connection?.send(JSON.stringify({
        action: 'subscribe',
        eventType
      }));
    },
    unsubscribe: (eventType) => {
      connection?.send(JSON.stringify({
        action: 'unsubscribe', 
        eventType
      }));
    }
  };
};
```

### 4.2 数据更新策略

#### 4.2.1 增量更新机制
```javascript
// 增量数据更新管理
class IncrementalDataManager {
  constructor() {
    this.dataCache = new Map();
    this.updateQueue = [];
    this.updateBatch = new Set();
    this.debounceTimer = null;
  }
  
  // 处理增量数据更新
  handleIncrementalUpdate(update) {
    const { type, tableId, columnId, data, timestamp } = update;
    
    // 添加到更新队列
    this.updateQueue.push({
      type,
      target: `${tableId}-${columnId}`,
      data,
      timestamp
    });
    
    // 批处理更新 (避免频繁重渲染)
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    
    this.debounceTimer = setTimeout(() => {
      this.processBatchUpdates();
    }, 100); // 100ms批处理窗口
  }
  
  processBatchUpdates() {
    const updates = [...this.updateQueue];
    this.updateQueue = [];
    
    // 按表格和列分组更新
    const groupedUpdates = this.groupUpdatesByTarget(updates);
    
    // 计算新的热力图数据
    const newHeatmapData = this.applyUpdatesToHeatmap(groupedUpdates);
    
    // 触发组件重新渲染
    this.notifyComponents(newHeatmapData);
  }
  
  applyUpdatesToHeatmap(groupedUpdates) {
    const currentData = this.getCurrentHeatmapData();
    
    for (const [target, updates] of groupedUpdates.entries()) {
      const [tableId, columnId] = target.split('-');
      const latestUpdate = this.getLatestUpdate(updates);
      
      // 更新对应的矩阵位置
      const tableIndex = this.getTableIndex(tableId);
      const columnIndex = this.getColumnIndex(columnId);
      
      if (tableIndex !== -1 && columnIndex !== -1) {
        currentData[tableIndex][columnIndex] = latestUpdate.data.riskScore;
      }
    }
    
    return currentData;
  }
}
```

## 5. 性能优化策略

### 5.1 组件性能优化

#### 5.1.1 渲染优化技术
```javascript
// 高性能热力图渲染优化
const OptimizedHeatmapRenderer = React.memo(({
  heatmapData,
  tableNames,
  columnNames,
  onCellHover,
  renderingConfig
}) => {
  // Canvas渲染优化
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  const lastRenderDataRef = useRef(null);
  
  // 仅在数据实际变化时重新渲染
  const shouldRerender = useMemo(() => {
    if (!lastRenderDataRef.current) return true;
    return !deepEqual(heatmapData, lastRenderDataRef.current);
  }, [heatmapData]);
  
  // 使用requestAnimationFrame优化渲染
  const scheduleRender = useCallback(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
    }
    
    animationFrameRef.current = requestAnimationFrame(() => {
      renderHeatmapToCanvas();
      lastRenderDataRef.current = heatmapData;
    });
  }, [heatmapData]);
  
  // Canvas渲染实现
  const renderHeatmapToCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas.getBoundingClientRect();
    
    // 高DPI适配
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    
    // 批量渲染优化
    ctx.save();
    
    // 渲染热力图矩阵
    const cellWidth = width / columnNames.length;
    const cellHeight = height / tableNames.length;
    
    for (let row = 0; row < heatmapData.length; row++) {
      for (let col = 0; col < heatmapData[row].length; col++) {
        const value = heatmapData[row][col];
        if (value > 0) {
          ctx.fillStyle = getScientificHeatColor(value);
          ctx.fillRect(
            col * cellWidth,
            row * cellHeight,
            cellWidth,
            cellHeight
          );
        }
      }
    }
    
    ctx.restore();
  }, [heatmapData, columnNames, tableNames]);
  
  useEffect(() => {
    if (shouldRerender) {
      scheduleRender();
    }
  }, [shouldRerender, scheduleRender]);
  
  return <canvas ref={canvasRef} className="optimized-heatmap-canvas" />;
}, (prevProps, nextProps) => {
  // 自定义比较函数，避免不必要的重渲染
  return (
    deepEqual(prevProps.heatmapData, nextProps.heatmapData) &&
    prevProps.tableNames.length === nextProps.tableNames.length &&
    prevProps.columnNames.length === nextProps.columnNames.length
  );
});
```

#### 5.1.2 大数据集优化
```javascript
// 虚拟化滚动优化 (用于大量表格场景)
const VirtualizedHeatmapContainer = ({
  totalRows,
  totalColumns,
  rowHeight,
  columnWidth,
  getData,
  renderCell
}) => {
  const containerRef = useRef(null);
  const [viewportInfo, setViewportInfo] = useState({
    scrollTop: 0,
    scrollLeft: 0,
    containerHeight: 0,
    containerWidth: 0
  });
  
  // 计算可见范围
  const visibleRange = useMemo(() => {
    const startRow = Math.floor(viewportInfo.scrollTop / rowHeight);
    const endRow = Math.min(
      totalRows,
      Math.ceil((viewportInfo.scrollTop + viewportInfo.containerHeight) / rowHeight)
    );
    
    const startCol = Math.floor(viewportInfo.scrollLeft / columnWidth);
    const endCol = Math.min(
      totalColumns,
      Math.ceil((viewportInfo.scrollLeft + viewportInfo.containerWidth) / columnWidth)
    );
    
    return { startRow, endRow, startCol, endCol };
  }, [viewportInfo, totalRows, totalColumns, rowHeight, columnWidth]);
  
  // 只渲染可见单元格
  const visibleCells = useMemo(() => {
    const cells = [];
    const { startRow, endRow, startCol, endCol } = visibleRange;
    
    for (let row = startRow; row < endRow; row++) {
      for (let col = startCol; col < endCol; col++) {
        const cellData = getData(row, col);
        if (cellData) {
          cells.push({
            row,
            col,
            data: cellData,
            style: {
              position: 'absolute',
              top: row * rowHeight,
              left: col * columnWidth,
              width: columnWidth,
              height: rowHeight
            }
          });
        }
      }
    }
    
    return cells;
  }, [visibleRange, getData]);
  
  return (
    <div 
      ref={containerRef}
      className="virtualized-heatmap"
      style={{
        position: 'relative',
        height: totalRows * rowHeight,
        width: totalColumns * columnWidth,
        overflow: 'auto'
      }}
      onScroll={(e) => {
        setViewportInfo({
          scrollTop: e.target.scrollTop,
          scrollLeft: e.target.scrollLeft,
          containerHeight: e.target.clientHeight,
          containerWidth: e.target.clientWidth
        });
      }}
    >
      {visibleCells.map(cell => 
        renderCell(cell.data, cell.style, `${cell.row}-${cell.col}`)
      )}
    </div>
  );
};
```

### 5.2 状态管理优化

#### 5.2.1 Context优化
```javascript
// 优化的全局状态管理
const HeatmapDataContext = React.createContext();

const HeatmapDataProvider = ({ children }) => {
  // 分离不同频率的状态更新
  const [staticData, setStaticData] = useState({
    tableNames: [],
    columnNames: [],
    columnRiskLevels: {}
  });
  
  const [dynamicData, setDynamicData] = useState({
    heatmapMatrix: [],
    modificationPatterns: [],
    statistics: {}
  });
  
  const [uiState, setUIState] = useState({
    hoveredCell: null,
    selectedCells: [],
    viewConfig: {}
  });
  
  // 优化的更新函数
  const updateDynamicData = useCallback((updates) => {
    setDynamicData(prev => ({
      ...prev,
      ...updates
    }));
  }, []);
  
  const updateUIState = useCallback((updates) => {
    setUIState(prev => ({
      ...prev,
      ...updates
    }));
  }, []);
  
  const contextValue = useMemo(() => ({
    staticData,
    dynamicData,
    uiState,
    setStaticData,
    updateDynamicData,
    updateUIState
  }), [staticData, dynamicData, uiState, updateDynamicData, updateUIState]);
  
  return (
    <HeatmapDataContext.Provider value={contextValue}>
      {children}
    </HeatmapDataContext.Provider>
  );
};
```

---

**文档版本**: v1.0  
**创建时间**: 2025-01-15  
**基于组件**: AdvancedSortedHeatmap.jsx (1381行) + UI参数体系  
**维护人员**: 前端开发团队
# ğŸ¯ è…¾è®¯æ–‡æ¡£è‡ªåŠ¨åŒ–ç™»å½•+ä¸Šä¼ å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“Œ æ ¸å¿ƒæˆåŠŸç»éªŒæ€»ç»“

### ä¸€ã€ç™»å½•æˆåŠŸçš„å…³é”®è¦ç´ 

#### 1. Cookieå¤„ç†çš„ç²¾é«“
```python
# âœ… æ­£ç¡®æ–¹æ³• - æ³¨æ„åˆ†å‰²ç¬¦åŒ…å«ç©ºæ ¼
cookie_string.split('; ')  # ä¸æ˜¯ split(';')

# âœ… æ­£ç¡®çš„åŸŸè®¾ç½® - åªç”¨ä¸€ä¸ªåŸŸ
'domain': '.docs.qq.com'  # ä¸è¦å¤šä¸ªåŸŸ
```

**æ·±å±‚åŸå› **ï¼š
- Cookieå­—ç¬¦ä¸²åœ¨æµè§ˆå™¨ä¸­æ˜¯ç”¨ `; `ï¼ˆåˆ†å·+ç©ºæ ¼ï¼‰åˆ†éš”çš„
- å¦‚æœç”¨ `split(';')` ä¼šå¯¼è‡´æ¯ä¸ªCookieå€¼å‰é¢æœ‰ç©ºæ ¼ï¼Œè§£æå¤±è´¥
- åªè®¾ç½® `.docs.qq.com` åŸŸå¯ä»¥è¦†ç›–æ‰€æœ‰å­åŸŸåï¼Œé¿å…é‡å¤

#### 2. è®¿é—®æµç¨‹çš„ä¼˜åŒ–
```python
# âœ… æˆåŠŸæµç¨‹
1. æ·»åŠ Cookie
2. ç›´æ¥è®¿é—® https://docs.qq.com/desktop/  # ä¸æ˜¯ä¸»é¡µ
3. ç­‰å¾…5ç§’å……åˆ†åŠ è½½
```

**æ·±å±‚åŸå› **ï¼š
- ç›´æ¥è®¿é—®æ¡Œé¢é¡µé¢é¿å…äº†é‡å®šå‘
- æ¡Œé¢é¡µé¢æ˜¯å·²ç™»å½•ç”¨æˆ·çš„é»˜è®¤é¡µé¢
- å……åˆ†ç­‰å¾…ç¡®ä¿æ‰€æœ‰å¼‚æ­¥åŠ è½½å®Œæˆ

### äºŒã€ä¸Šä¼ æˆåŠŸçš„å…³é”®æ­¥éª¤

#### 1. å¯¼å…¥æŒ‰é’®çš„ç²¾ç¡®å®šä½
```python
# æŒ‰é’®é€‰æ‹©å™¨ä¼˜å…ˆçº§
'button.desktop-import-button-pc'  # æœ€ç²¾ç¡®
'nav button:has(i.desktop-icon-import)'  # å¤‡é€‰
```

#### 2. æ–‡ä»¶é€‰æ‹©çš„æŠ€æœ¯è¦ç‚¹
```python
# ä¸¤ç§æ–‡ä»¶é€‰æ‹©æ–¹å¼
æ–¹å¼1: input[type="file"] å…ƒç´ 
æ–¹å¼2: Playwrightçš„filechooser API
```

#### 3. ç¡®è®¤å¼¹çª—çš„å¤„ç†
```python
# å¼¹çª—ç¡®è®¤æŒ‰é’®é€‰æ‹©å™¨
'button.dui-button-type-primary:has-text("ç¡®å®š")'
```

---

## ğŸ’ å®Œæ•´å¯å¤ç”¨ä»£ç ï¼ˆç”Ÿäº§çº§ï¼‰

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
è…¾è®¯æ–‡æ¡£è‡ªåŠ¨åŒ–ç™»å½•ä¸Šä¼  - ç”Ÿäº§çº§å®Œæ•´å®ç°
ç»è¿‡éªŒè¯çš„æˆåŠŸç‰ˆæœ¬
"""

import asyncio
import json
import os
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from playwright.async_api import async_playwright, Browser, BrowserContext, Page

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class TencentDocAutomation:
    """
    è…¾è®¯æ–‡æ¡£è‡ªåŠ¨åŒ–æ“ä½œç±»
    åŒ…å«ç™»å½•å’Œä¸Šä¼ çš„å®Œæ•´å®ç°
    """
    
    def __init__(self, headless: bool = False):
        """
        åˆå§‹åŒ–
        
        Args:
            headless: æ˜¯å¦æ— å¤´æ¨¡å¼ï¼Œå»ºè®®Falseä¾¿äºè°ƒè¯•
        """
        self.headless = headless
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
    async def __aenter__(self):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        await self.start()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å‡ºå£"""
        await self.cleanup()
        
    async def start(self) -> bool:
        """
        å¯åŠ¨æµè§ˆå™¨
        
        Returns:
            bool: æ˜¯å¦æˆåŠŸå¯åŠ¨
        """
        try:
            self.playwright = await async_playwright().start()
            
            # æµè§ˆå™¨å¯åŠ¨å‚æ•°
            self.browser = await self.playwright.chromium.launch(
                headless=self.headless,
                args=[
                    '--start-maximized',  # æœ€å¤§åŒ–çª—å£
                    '--no-sandbox',       # é¿å…æ²™ç®±é™åˆ¶
                    '--disable-blink-features=AutomationControlled',  # é¿å…æ£€æµ‹
                    '--disable-dev-shm-usage'  # é¿å…å†…å­˜é—®é¢˜
                ]
            )
            
            # åˆ›å»ºä¸Šä¸‹æ–‡
            self.context = await self.browser.new_context(
                accept_downloads=True,
                viewport={'width': 1920, 'height': 1080},
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            )
            
            # åˆ›å»ºé¡µé¢
            self.page = await self.context.new_page()
            
            logger.info("âœ… æµè§ˆå™¨å¯åŠ¨æˆåŠŸ")
            return True
            
        except Exception as e:
            logger.error(f"âŒ æµè§ˆå™¨å¯åŠ¨å¤±è´¥: {e}")
            return False
    
    def parse_cookie_string(self, cookie_string: str) -> list:
        """
        è§£æCookieå­—ç¬¦ä¸²
        
        å…³é”®ç‚¹ï¼š
        1. ä½¿ç”¨ '; ' åˆ†å‰²ï¼ˆæ³¨æ„ç©ºæ ¼ï¼‰
        2. åªè®¾ç½® .docs.qq.com åŸŸ
        3. ä¿æŒåŸå§‹å€¼ä¸ç¼–ç 
        
        Args:
            cookie_string: ä»æµè§ˆå™¨å¤åˆ¶çš„Cookieå­—ç¬¦ä¸²
            
        Returns:
            list: Cookieå­—å…¸åˆ—è¡¨
        """
        cookies = []
        
        # å…³é”®ï¼šä½¿ç”¨ '; ' è€Œä¸æ˜¯ ';'
        for cookie_pair in cookie_string.split('; '):
            if '=' in cookie_pair:
                name, value = cookie_pair.strip().split('=', 1)
                cookies.append({
                    'name': name.strip(),
                    'value': value.strip(),
                    'domain': '.docs.qq.com',  # å…³é”®ï¼šåªç”¨è¿™ä¸ªåŸŸ
                    'path': '/'
                })
        
        return cookies
    
    async def login_with_cookies(self, cookie_string: str) -> bool:
        """
        ä½¿ç”¨Cookieç™»å½•è…¾è®¯æ–‡æ¡£
        
        å…³é”®æµç¨‹ï¼š
        1. æ·»åŠ Cookie
        2. ç›´æ¥è®¿é—®æ¡Œé¢é¡µé¢ï¼ˆä¸æ˜¯ä¸»é¡µï¼‰
        3. å……åˆ†ç­‰å¾…é¡µé¢åŠ è½½
        4. éªŒè¯ç™»å½•çŠ¶æ€
        
        Args:
            cookie_string: Cookieå­—ç¬¦ä¸²
            
        Returns:
            bool: æ˜¯å¦ç™»å½•æˆåŠŸ
        """
        try:
            logger.info("ğŸ” å¼€å§‹Cookieç™»å½•...")
            
            # æ­¥éª¤1ï¼šè§£æå¹¶æ·»åŠ Cookie
            cookies = self.parse_cookie_string(cookie_string)
            await self.context.add_cookies(cookies)
            logger.info(f"âœ… å·²æ·»åŠ  {len(cookies)} ä¸ªCookies")
            
            # æ­¥éª¤2ï¼šç›´æ¥è®¿é—®æ¡Œé¢é¡µé¢ï¼ˆå…³é”®ï¼‰
            await self.page.goto(
                'https://docs.qq.com/desktop/',  # æ³¨æ„æ˜¯desktopä¸æ˜¯ä¸»é¡µ
                wait_until='domcontentloaded',
                timeout=30000
            )
            
            # æ­¥éª¤3ï¼šå……åˆ†ç­‰å¾…ï¼ˆé‡è¦ï¼‰
            await self.page.wait_for_timeout(5000)
            
            # æ­¥éª¤4ï¼šéªŒè¯ç™»å½•çŠ¶æ€
            is_logged_in = await self.verify_login_status()
            
            if is_logged_in:
                logger.info("âœ… ç™»å½•æˆåŠŸï¼")
                return True
            else:
                logger.warning("âš ï¸ ç™»å½•å¤±è´¥ï¼Œå¯èƒ½Cookieå·²è¿‡æœŸ")
                return False
                
        except Exception as e:
            logger.error(f"âŒ ç™»å½•å¼‚å¸¸: {e}")
            return False
    
    async def verify_login_status(self) -> bool:
        """
        éªŒè¯ç™»å½•çŠ¶æ€
        
        åˆ¤æ–­æ ‡å‡†ï¼š
        1. æ— ç™»å½•æŒ‰é’®
        2. æœ‰å¯¼å…¥æŒ‰é’®
        3. æœ‰ç”¨æˆ·ä¿¡æ¯
        
        Returns:
            bool: æ˜¯å¦å·²ç™»å½•
        """
        try:
            # è·å–é¡µé¢æ ‡é¢˜
            title = await self.page.title()
            logger.info(f"ğŸ“„ é¡µé¢æ ‡é¢˜: {title}")
            
            # æ£€æŸ¥ç™»å½•æŒ‰é’®ï¼ˆä¸åº”å­˜åœ¨ï¼‰
            login_btn = await self.page.query_selector('button:has-text("ç™»å½•")')
            has_login_btn = login_btn is not None
            
            # æ£€æŸ¥å¯¼å…¥æŒ‰é’®ï¼ˆåº”è¯¥å­˜åœ¨ï¼‰
            import_btn = await self.page.query_selector('button.desktop-import-button-pc')
            has_import_btn = import_btn is not None
            
            # æ£€æŸ¥ç”¨æˆ·ä¿¡æ¯
            user_info = await self.page.query_selector('[class*="avatar"], [class*="user"]')
            has_user_info = user_info is not None
            
            logger.info(f"ğŸ” çŠ¶æ€æ£€æŸ¥: ç™»å½•æŒ‰é’®={has_login_btn}, å¯¼å…¥æŒ‰é’®={has_import_btn}, ç”¨æˆ·ä¿¡æ¯={has_user_info}")
            
            # åˆ¤æ–­ï¼šæ— ç™»å½•æŒ‰é’® ä¸” (æœ‰å¯¼å…¥æŒ‰é’® æˆ– æœ‰ç”¨æˆ·ä¿¡æ¯)
            return not has_login_btn and (has_import_btn or has_user_info)
            
        except Exception as e:
            logger.error(f"âŒ çŠ¶æ€éªŒè¯å¤±è´¥: {e}")
            return False
    
    async def upload_file(self, file_path: str) -> Dict[str, Any]:
        """
        ä¸Šä¼ æ–‡ä»¶åˆ°è…¾è®¯æ–‡æ¡£
        
        å®Œæ•´æµç¨‹ï¼š
        1. ç‚¹å‡»å¯¼å…¥æŒ‰é’®
        2. é€‰æ‹©æ–‡ä»¶
        3. ç¡®è®¤ä¸Šä¼ é€‰é¡¹
        4. ç­‰å¾…ä¸Šä¼ å®Œæˆ
        
        Args:
            file_path: è¦ä¸Šä¼ çš„æ–‡ä»¶è·¯å¾„
            
        Returns:
            dict: åŒ…å«æˆåŠŸçŠ¶æ€å’Œæ–‡æ¡£URLçš„ç»“æœ
        """
        result = {'success': False, 'url': None, 'message': ''}
        
        try:
            # ç¡®ä¿æ–‡ä»¶å­˜åœ¨
            file_path = Path(file_path).resolve()
            if not file_path.exists():
                result['message'] = f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}"
                return result
            
            logger.info(f"ğŸ“¤ å¼€å§‹ä¸Šä¼ : {file_path.name}")
            
            # æ­¥éª¤1ï¼šç‚¹å‡»å¯¼å…¥æŒ‰é’®
            import_btn = await self.click_import_button()
            if not import_btn:
                result['message'] = "æœªæ‰¾åˆ°å¯¼å…¥æŒ‰é’®"
                return result
            
            # æ­¥éª¤2ï¼šå¤„ç†æ–‡ä»¶é€‰æ‹©
            await self.handle_file_selection(str(file_path))
            
            # æ­¥éª¤3ï¼šç¡®è®¤ä¸Šä¼ 
            await self.confirm_upload_dialog()
            
            # æ­¥éª¤4ï¼šç­‰å¾…ä¸Šä¼ å®Œæˆå¹¶è·å–URL
            success, url = await self.wait_for_upload_complete()
            
            if success:
                result['success'] = True
                result['url'] = url
                result['message'] = "ä¸Šä¼ æˆåŠŸ"
                logger.info(f"âœ… ä¸Šä¼ æˆåŠŸ: {url}")
            else:
                result['message'] = "ä¸Šä¼ è¶…æ—¶æˆ–å¤±è´¥"
                
        except Exception as e:
            result['message'] = f"ä¸Šä¼ å¼‚å¸¸: {str(e)}"
            logger.error(f"âŒ ä¸Šä¼ å¼‚å¸¸: {e}")
            
        return result
    
    async def click_import_button(self) -> bool:
        """
        ç‚¹å‡»å¯¼å…¥æŒ‰é’®
        
        ä½¿ç”¨å¤šä¸ªé€‰æ‹©å™¨ç¡®ä¿æ‰¾åˆ°æŒ‰é’®
        
        Returns:
            bool: æ˜¯å¦æˆåŠŸç‚¹å‡»
        """
        import_selectors = [
            'button.desktop-import-button-pc',  # ç±»é€‰æ‹©å™¨ï¼ˆæœ€å‡†ç¡®ï¼‰
            'nav button:has(i.desktop-icon-import)',  # å›¾æ ‡é€‰æ‹©å™¨
            'button:has-text("å¯¼å…¥")',  # æ–‡æœ¬é€‰æ‹©å™¨
        ]
        
        for selector in import_selectors:
            try:
                btn = await self.page.wait_for_selector(selector, timeout=3000)
                if btn:
                    await btn.click()
                    logger.info(f"âœ… ç‚¹å‡»å¯¼å…¥æŒ‰é’®: {selector}")
                    return True
            except:
                continue
                
        logger.error("âŒ æœªæ‰¾åˆ°å¯¼å…¥æŒ‰é’®")
        return False
    
    async def handle_file_selection(self, file_path: str):
        """
        å¤„ç†æ–‡ä»¶é€‰æ‹©
        
        ä¸¤ç§æ–¹å¼ï¼š
        1. ç›´æ¥è®¾ç½®input[type="file"]
        2. ä½¿ç”¨filechooser API
        
        Args:
            file_path: æ–‡ä»¶ç»å¯¹è·¯å¾„
        """
        # ç­‰å¾…ä¸€ä¸‹è®©æ–‡ä»¶é€‰æ‹©å™¨å‡†å¤‡å¥½
        await self.page.wait_for_timeout(1000)
        
        # æ–¹å¼1ï¼šæŸ¥æ‰¾file input
        file_inputs = await self.page.query_selector_all('input[type="file"]')
        
        if file_inputs:
            # ä½¿ç”¨æœ€åä¸€ä¸ªï¼ˆé€šå¸¸æ˜¯æœ€æ–°çš„ï¼‰
            await file_inputs[-1].set_input_files(file_path)
            logger.info(f"âœ… é€šè¿‡inputé€‰æ‹©æ–‡ä»¶: {file_path}")
        else:
            # æ–¹å¼2ï¼šä½¿ç”¨filechooser
            logger.info("ä½¿ç”¨filechooseré€‰æ‹©æ–‡ä»¶")
            async with self.page.expect_file_chooser() as fc_info:
                # é‡æ–°è§¦å‘æ–‡ä»¶é€‰æ‹©å™¨
                await self.click_import_button()
            
            file_chooser = await fc_info.value
            await file_chooser.set_files(file_path)
            logger.info(f"âœ… é€šè¿‡filechooseré€‰æ‹©æ–‡ä»¶: {file_path}")
    
    async def confirm_upload_dialog(self):
        """
        ç¡®è®¤ä¸Šä¼ å¯¹è¯æ¡†
        
        å¤„ç†"å¯¼å…¥æœ¬åœ°æ–‡ä»¶"å¼¹çª—
        """
        try:
            # ç­‰å¾…å¼¹çª—å‡ºç°
            await self.page.wait_for_timeout(2000)
            
            # æ£€æŸ¥å¼¹çª—
            modal = await self.page.query_selector('.import-kit-import-modal-title:has-text("å¯¼å…¥æœ¬åœ°æ–‡ä»¶")')
            if modal:
                logger.info("âœ… å¯¼å…¥å¼¹çª—å·²å‡ºç°")
            
            # ç‚¹å‡»ç¡®å®šæŒ‰é’®
            confirm_selectors = [
                'button.dui-button-type-primary:has-text("ç¡®å®š")',
                '.import-kit-import-file-footer button.dui-button-type-primary',
                'button.dui-button-type-primary .dui-button-container:has-text("ç¡®å®š")'
            ]
            
            for selector in confirm_selectors:
                try:
                    btn = await self.page.wait_for_selector(selector, timeout=2000)
                    if btn:
                        await btn.click()
                        logger.info("âœ… ç‚¹å‡»ç¡®å®šæŒ‰é’®")
                        return
                except:
                    continue
            
            # å¤‡ç”¨æ–¹æ¡ˆï¼šæŒ‰Enteré”®
            await self.page.keyboard.press('Enter')
            logger.info("âœ… ä½¿ç”¨Enteré”®ç¡®è®¤")
            
        except Exception as e:
            logger.warning(f"âš ï¸ ç¡®è®¤å¯¹è¯æ¡†å¤„ç†: {e}")
    
    async def wait_for_upload_complete(self, timeout: int = 30) -> tuple:
        """
        ç­‰å¾…ä¸Šä¼ å®Œæˆ
        
        åˆ¤æ–­æ ‡å‡†ï¼šURLå˜åŒ–åˆ°æ–‡æ¡£é¡µé¢
        
        Args:
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            
        Returns:
            tuple: (æ˜¯å¦æˆåŠŸ, æ–‡æ¡£URL)
        """
        logger.info("â³ ç­‰å¾…ä¸Šä¼ å®Œæˆ...")
        
        for _ in range(timeout // 5):
            await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            if '/sheet/' in current_url or '/doc/' in current_url or '/slide/' in current_url:
                return True, current_url
        
        return False, None
    
    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        logger.info("ğŸ”š èµ„æºå·²æ¸…ç†")


# ============= ä½¿ç”¨ç¤ºä¾‹ =============

async def main_example():
    """
    å®Œæ•´ä½¿ç”¨ç¤ºä¾‹
    å±•ç¤ºç™»å½•å’Œä¸Šä¼ çš„å®Œæ•´æµç¨‹
    """
    
    # é…ç½®
    COOKIE_FILE = 'config/cookies.json'
    TEST_FILE = 'å‰¯æœ¬-å‰¯æœ¬-æµ‹è¯•ç‰ˆæœ¬-å‡ºå›½é”€å”®è®¡åˆ’è¡¨.xlsx'
    
    # è¯»å–Cookie
    with open(COOKIE_FILE, 'r', encoding='utf-8') as f:
        config = json.load(f)
        cookie_string = config['cookie_string']
    
    # ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨è‡ªåŠ¨ç®¡ç†èµ„æº
    async with TencentDocAutomation(headless=False) as automation:
        
        # 1. ç™»å½•
        login_success = await automation.login_with_cookies(cookie_string)
        if not login_success:
            logger.error("ç™»å½•å¤±è´¥")
            return
        
        # 2. ä¸Šä¼ æ–‡ä»¶
        result = await automation.upload_file(TEST_FILE)
        
        # 3. å¤„ç†ç»“æœ
        if result['success']:
            print(f"\nâœ… ä¸Šä¼ æˆåŠŸï¼")
            print(f"ğŸ“„ æ–‡æ¡£URL: {result['url']}")
        else:
            print(f"\nâŒ ä¸Šä¼ å¤±è´¥: {result['message']}")
        
        # 4. ä¿æŒæµè§ˆå™¨æ‰“å¼€ä¾›è§‚å¯Ÿ
        await asyncio.sleep(30)


# ============= ç®€åŒ–ç‰ˆæœ¬ =============

class SimpleTencentUploader:
    """
    ç®€åŒ–ç‰ˆä¸Šä¼ å™¨
    æœ€å°‘ä»£ç å®ç°æ ¸å¿ƒåŠŸèƒ½
    """
    
    @staticmethod
    async def quick_upload(cookie_string: str, file_path: str) -> bool:
        """
        å¿«é€Ÿä¸Šä¼ æ–‡ä»¶
        
        Args:
            cookie_string: Cookieå­—ç¬¦ä¸²
            file_path: æ–‡ä»¶è·¯å¾„
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        from playwright.async_api import async_playwright
        
        async with async_playwright() as p:
            # å¯åŠ¨æµè§ˆå™¨
            browser = await p.chromium.launch(headless=False)
            context = await browser.new_context()
            page = await context.new_page()
            
            try:
                # æ·»åŠ Cookie
                cookies = []
                for cookie_pair in cookie_string.split('; '):
                    if '=' in cookie_pair:
                        name, value = cookie_pair.split('=', 1)
                        cookies.append({
                            'name': name.strip(),
                            'value': value.strip(),
                            'domain': '.docs.qq.com',
                            'path': '/'
                        })
                await context.add_cookies(cookies)
                
                # è®¿é—®é¡µé¢
                await page.goto('https://docs.qq.com/desktop/')
                await page.wait_for_timeout(5000)
                
                # ç‚¹å‡»å¯¼å…¥
                import_btn = await page.wait_for_selector('button.desktop-import-button-pc')
                await import_btn.click()
                
                # é€‰æ‹©æ–‡ä»¶
                await page.wait_for_timeout(1000)
                file_inputs = await page.query_selector_all('input[type="file"]')
                if file_inputs:
                    await file_inputs[-1].set_input_files(file_path)
                
                # ç¡®è®¤ä¸Šä¼ 
                await page.wait_for_timeout(2000)
                confirm_btn = await page.query_selector('button.dui-button-type-primary:has-text("ç¡®å®š")')
                if confirm_btn:
                    await confirm_btn.click()
                
                # ç­‰å¾…å®Œæˆ
                await page.wait_for_timeout(10000)
                
                # æ£€æŸ¥ç»“æœ
                url = page.url
                return '/sheet/' in url or '/doc/' in url
                
            finally:
                await browser.close()


if __name__ == "__main__":
    # è¿è¡Œç¤ºä¾‹
    asyncio.run(main_example())
```

---

## ğŸ”§ å…³é”®æŠ€æœ¯ç‚¹æ·±åº¦è§£æ

### 1. Cookieå¤„ç†çš„æœ¬è´¨

Cookieå­—ç¬¦ä¸²åœ¨æµè§ˆå™¨ä¸­çš„æ ¼å¼ï¼š
```
name1=value1; name2=value2; name3=value3
```

æ³¨æ„æ¯ä¸ªCookieä¹‹é—´æ˜¯ `; `ï¼ˆåˆ†å·+ç©ºæ ¼ï¼‰ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„åˆ†å·ã€‚

**é”™è¯¯ç¤ºä¾‹**ï¼š
```python
'fingerprint=xxx;low_login_enable=1'  # ç´§å‡‘æ ¼å¼
split(';')  # ç»“æœï¼š['fingerprint=xxx', 'low_login_enable=1']
```

**æ­£ç¡®ç¤ºä¾‹**ï¼š
```python
'fingerprint=xxx; low_login_enable=1'  # æ ‡å‡†æ ¼å¼
split('; ')  # ç»“æœï¼š['fingerprint=xxx', 'low_login_enable=1']
```

### 2. é¡µé¢è®¿é—®ç­–ç•¥

**ä¸ºä»€ä¹ˆç›´æ¥è®¿é—® `/desktop/`ï¼Ÿ**

- ä¸»é¡µ `https://docs.qq.com/` ä¼šæ ¹æ®ç™»å½•çŠ¶æ€é‡å®šå‘
- æ¡Œé¢é¡µ `https://docs.qq.com/desktop/` æ˜¯ç™»å½•åçš„é»˜è®¤é¡µé¢
- ç›´æ¥è®¿é—®æ¡Œé¢é¡µé¿å…äº†é‡å®šå‘ï¼Œæ›´ç¨³å®š

### 3. æ–‡ä»¶é€‰æ‹©çš„ä¸¤ç§æ–¹å¼

**æ–¹å¼1ï¼šHTML5 File Input**
```python
file_input = await page.query_selector('input[type="file"]')
await file_input.set_input_files(file_path)
```

**æ–¹å¼2ï¼šPlaywright FileChooser API**
```python
async with page.expect_file_chooser() as fc_info:
    await trigger_button.click()
file_chooser = await fc_info.value
await file_chooser.set_files(file_path)
```

è…¾è®¯æ–‡æ¡£å¯èƒ½åŠ¨æ€åˆ›å»ºfile inputï¼Œæ‰€ä»¥éœ€è¦ä¸¤ç§æ–¹å¼éƒ½å‡†å¤‡ã€‚

### 4. ç­‰å¾…ç­–ç•¥çš„é‡è¦æ€§

```python
# å…³é”®ç­‰å¾…ç‚¹
await page.wait_for_timeout(5000)  # ç™»å½•åç­‰å¾…
await page.wait_for_timeout(1000)  # ç‚¹å‡»æŒ‰é’®åç­‰å¾…
await page.wait_for_timeout(2000)  # å¼¹çª—å‡ºç°ç­‰å¾…
```

è¿™äº›ç­‰å¾…ä¸æ˜¯éšæ„çš„ï¼Œè€Œæ˜¯åŸºäºï¼š
- é¡µé¢å¼‚æ­¥åŠ è½½
- React/Vueç»„ä»¶æ¸²æŸ“
- ç½‘ç»œè¯·æ±‚å®Œæˆ

---

## ğŸ“Š æˆåŠŸç‡æå‡æŠ€å·§

### 1. å¤šé‡é€‰æ‹©å™¨ç­–ç•¥
```python
selectors = [
    'button.desktop-import-button-pc',  # ç²¾ç¡®ç±»å
    'nav button:has(i.desktop-icon-import)',  # ç»“æ„é€‰æ‹©
    'button:has-text("å¯¼å…¥")'  # æ–‡æœ¬åŒ¹é…
]
```

### 2. é”™è¯¯é‡è¯•æœºåˆ¶
```python
async def retry_operation(func, max_retries=3):
    for i in range(max_retries):
        try:
            return await func()
        except Exception as e:
            if i == max_retries - 1:
                raise
            await asyncio.sleep(2 ** i)  # æŒ‡æ•°é€€é¿
```

### 3. çŠ¶æ€éªŒè¯é“¾
```python
# éªŒè¯é“¾
ç™»å½•çŠ¶æ€ â†’ æŒ‰é’®å­˜åœ¨ â†’ æ–‡ä»¶é€‰æ‹© â†’ å¼¹çª—ç¡®è®¤ â†’ URLå˜åŒ–
```

---

## ğŸš€ å¿«é€Ÿå¼€å§‹æŒ‡å—

### 1. å®‰è£…ä¾èµ–
```bash
pip install playwright
playwright install chromium
```

### 2. è·å–Cookie
1. Chromeç™»å½•è…¾è®¯æ–‡æ¡£
2. F12 â†’ Network â†’ åˆ·æ–°
3. æ‰¾åˆ°ä»»æ„è¯·æ±‚ â†’ Headers â†’ Cookie
4. å¤åˆ¶å®Œæ•´Cookieå­—ç¬¦ä¸²

### 3. é…ç½®æ–‡ä»¶
```json
{
  "cookie_string": "ä½ çš„Cookieå­—ç¬¦ä¸²"
}
```

### 4. è¿è¡Œä»£ç 
```python
import asyncio
from your_script import SimpleTencentUploader

cookie = "ä½ çš„Cookie"
file = "ä½ çš„æ–‡ä»¶.xlsx"

asyncio.run(SimpleTencentUploader.quick_upload(cookie, file))
```

---

## â“ å¸¸è§é—®é¢˜è§£å†³

### Q1: Cookieè¿‡æœŸæ€ä¹ˆåŠï¼Ÿ
A: Cookieé€šå¸¸æœ‰æ•ˆæœŸ7-30å¤©ï¼Œéœ€è¦å®šæœŸæ›´æ–°ã€‚å¯ä»¥å®ç°è‡ªåŠ¨æ£€æµ‹å’Œæé†’æœºåˆ¶ã€‚

### Q2: æ–‡ä»¶é€‰æ‹©å¤±è´¥ï¼Ÿ
A: ç¡®ä¿æ–‡ä»¶è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„ï¼Œä½¿ç”¨ `Path(file).resolve()`

### Q3: ä¸Šä¼ åæ²¡æœ‰è·³è½¬ï¼Ÿ
A: å¯èƒ½æ˜¯å¤§æ–‡ä»¶å¤„ç†æ—¶é—´é•¿ï¼Œå¢åŠ ç­‰å¾…æ—¶é—´ã€‚

### Q4: å¦‚ä½•æ‰¹é‡ä¸Šä¼ ï¼Ÿ
A: å¾ªç¯è°ƒç”¨upload_fileæ–¹æ³•ï¼Œæ¯æ¬¡ä¸Šä¼ åç­‰å¾…å‡ ç§’ã€‚

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¹¶å‘é™åˆ¶**ï¼šä¸è¦åŒæ—¶å¼€å¤šä¸ªæµè§ˆå™¨å®ä¾‹
2. **èµ„æºæ¸…ç†**ï¼šä½¿ç”¨å®ŒåŠæ—¶å…³é—­æµè§ˆå™¨
3. **ç¼“å­˜åˆ©ç”¨**ï¼šå¯ä»¥ä¿æŒcontextå¤ç”¨
4. **æ—¥å¿—ä¼˜åŒ–**ï¼šç”Ÿäº§ç¯å¢ƒå‡å°‘æ—¥å¿—è¾“å‡º

---

## ğŸ¯ æ ¸å¿ƒè¦ç‚¹æ€»ç»“

1. **Cookieå¤„ç†**ï¼šå¿…é¡»ç”¨ `'; '` åˆ†å‰²ï¼Œåªè®¾ç½® `.docs.qq.com` åŸŸ
2. **è®¿é—®æµç¨‹**ï¼šç›´æ¥è®¿é—® `/desktop/` é¡µé¢
3. **ç­‰å¾…ç­–ç•¥**ï¼šå……åˆ†ç­‰å¾…é¡µé¢åŠ è½½ï¼ˆ5ç§’ï¼‰
4. **é€‰æ‹©å™¨ç­–ç•¥**ï¼šä½¿ç”¨å¤šä¸ªé€‰æ‹©å™¨æé«˜æˆåŠŸç‡
5. **æ–‡ä»¶å¤„ç†**ï¼šæ”¯æŒä¸¤ç§æ–‡ä»¶é€‰æ‹©æ–¹å¼
6. **çŠ¶æ€éªŒè¯**ï¼šé€šè¿‡URLå˜åŒ–åˆ¤æ–­ä¸Šä¼ æˆåŠŸ

è¿™å¥—æ–¹æ¡ˆç»è¿‡å®é™…éªŒè¯ï¼ŒæˆåŠŸç‡é«˜ï¼Œå¯ä»¥ç›´æ¥ç”¨äºç”Ÿäº§ç¯å¢ƒã€‚
# 🎯 腾讯文档自动化登录+上传完整解决方案

## 📌 核心成功经验总结

### 一、登录成功的关键要素

#### 1. Cookie处理的精髓
```python
# ✅ 正确方法 - 注意分割符包含空格
cookie_string.split('; ')  # 不是 split(';')

# ✅ 正确的域设置 - 只用一个域
'domain': '.docs.qq.com'  # 不要多个域
```

**深层原因**：
- Cookie字符串在浏览器中是用 `; `（分号+空格）分隔的
- 如果用 `split(';')` 会导致每个Cookie值前面有空格，解析失败
- 只设置 `.docs.qq.com` 域可以覆盖所有子域名，避免重复

#### 2. 访问流程的优化
```python
# ✅ 成功流程
1. 添加Cookie
2. 直接访问 https://docs.qq.com/desktop/  # 不是主页
3. 等待5秒充分加载
```

**深层原因**：
- 直接访问桌面页面避免了重定向
- 桌面页面是已登录用户的默认页面
- 充分等待确保所有异步加载完成

### 二、上传成功的关键步骤

#### 1. 导入按钮的精确定位
```python
# 按钮选择器优先级
'button.desktop-import-button-pc'  # 最精确
'nav button:has(i.desktop-icon-import)'  # 备选
```

#### 2. 文件选择的技术要点
```python
# 两种文件选择方式
方式1: input[type="file"] 元素
方式2: Playwright的filechooser API
```

#### 3. 确认弹窗的处理
```python
# 弹窗确认按钮选择器
'button.dui-button-type-primary:has-text("确定")'
```

---

## 💎 完整可复用代码（生产级）

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
腾讯文档自动化登录上传 - 生产级完整实现
经过验证的成功版本
"""

import asyncio
import json
import os
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from playwright.async_api import async_playwright, Browser, BrowserContext, Page

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class TencentDocAutomation:
    """
    腾讯文档自动化操作类
    包含登录和上传的完整实现
    """
    
    def __init__(self, headless: bool = False):
        """
        初始化
        
        Args:
            headless: 是否无头模式，建议False便于调试
        """
        self.headless = headless
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
    async def __aenter__(self):
        """异步上下文管理器入口"""
        await self.start()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器出口"""
        await self.cleanup()
        
    async def start(self) -> bool:
        """
        启动浏览器
        
        Returns:
            bool: 是否成功启动
        """
        try:
            self.playwright = await async_playwright().start()
            
            # 浏览器启动参数
            self.browser = await self.playwright.chromium.launch(
                headless=self.headless,
                args=[
                    '--start-maximized',  # 最大化窗口
                    '--no-sandbox',       # 避免沙箱限制
                    '--disable-blink-features=AutomationControlled',  # 避免检测
                    '--disable-dev-shm-usage'  # 避免内存问题
                ]
            )
            
            # 创建上下文
            self.context = await self.browser.new_context(
                accept_downloads=True,
                viewport={'width': 1920, 'height': 1080},
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            )
            
            # 创建页面
            self.page = await self.context.new_page()
            
            logger.info("✅ 浏览器启动成功")
            return True
            
        except Exception as e:
            logger.error(f"❌ 浏览器启动失败: {e}")
            return False
    
    def parse_cookie_string(self, cookie_string: str) -> list:
        """
        解析Cookie字符串
        
        关键点：
        1. 使用 '; ' 分割（注意空格）
        2. 只设置 .docs.qq.com 域
        3. 保持原始值不编码
        
        Args:
            cookie_string: 从浏览器复制的Cookie字符串
            
        Returns:
            list: Cookie字典列表
        """
        cookies = []
        
        # 关键：使用 '; ' 而不是 ';'
        for cookie_pair in cookie_string.split('; '):
            if '=' in cookie_pair:
                name, value = cookie_pair.strip().split('=', 1)
                cookies.append({
                    'name': name.strip(),
                    'value': value.strip(),
                    'domain': '.docs.qq.com',  # 关键：只用这个域
                    'path': '/'
                })
        
        return cookies
    
    async def login_with_cookies(self, cookie_string: str) -> bool:
        """
        使用Cookie登录腾讯文档
        
        关键流程：
        1. 添加Cookie
        2. 直接访问桌面页面（不是主页）
        3. 充分等待页面加载
        4. 验证登录状态
        
        Args:
            cookie_string: Cookie字符串
            
        Returns:
            bool: 是否登录成功
        """
        try:
            logger.info("🔐 开始Cookie登录...")
            
            # 步骤1：解析并添加Cookie
            cookies = self.parse_cookie_string(cookie_string)
            await self.context.add_cookies(cookies)
            logger.info(f"✅ 已添加 {len(cookies)} 个Cookies")
            
            # 步骤2：直接访问桌面页面（关键）
            await self.page.goto(
                'https://docs.qq.com/desktop/',  # 注意是desktop不是主页
                wait_until='domcontentloaded',
                timeout=30000
            )
            
            # 步骤3：充分等待（重要）
            await self.page.wait_for_timeout(5000)
            
            # 步骤4：验证登录状态
            is_logged_in = await self.verify_login_status()
            
            if is_logged_in:
                logger.info("✅ 登录成功！")
                return True
            else:
                logger.warning("⚠️ 登录失败，可能Cookie已过期")
                return False
                
        except Exception as e:
            logger.error(f"❌ 登录异常: {e}")
            return False
    
    async def verify_login_status(self) -> bool:
        """
        验证登录状态
        
        判断标准：
        1. 无登录按钮
        2. 有导入按钮
        3. 有用户信息
        
        Returns:
            bool: 是否已登录
        """
        try:
            # 获取页面标题
            title = await self.page.title()
            logger.info(f"📄 页面标题: {title}")
            
            # 检查登录按钮（不应存在）
            login_btn = await self.page.query_selector('button:has-text("登录")')
            has_login_btn = login_btn is not None
            
            # 检查导入按钮（应该存在）
            import_btn = await self.page.query_selector('button.desktop-import-button-pc')
            has_import_btn = import_btn is not None
            
            # 检查用户信息
            user_info = await self.page.query_selector('[class*="avatar"], [class*="user"]')
            has_user_info = user_info is not None
            
            logger.info(f"🔍 状态检查: 登录按钮={has_login_btn}, 导入按钮={has_import_btn}, 用户信息={has_user_info}")
            
            # 判断：无登录按钮 且 (有导入按钮 或 有用户信息)
            return not has_login_btn and (has_import_btn or has_user_info)
            
        except Exception as e:
            logger.error(f"❌ 状态验证失败: {e}")
            return False
    
    async def upload_file(self, file_path: str) -> Dict[str, Any]:
        """
        上传文件到腾讯文档
        
        完整流程：
        1. 点击导入按钮
        2. 选择文件
        3. 确认上传选项
        4. 等待上传完成
        
        Args:
            file_path: 要上传的文件路径
            
        Returns:
            dict: 包含成功状态和文档URL的结果
        """
        result = {'success': False, 'url': None, 'message': ''}
        
        try:
            # 确保文件存在
            file_path = Path(file_path).resolve()
            if not file_path.exists():
                result['message'] = f"文件不存在: {file_path}"
                return result
            
            logger.info(f"📤 开始上传: {file_path.name}")
            
            # 步骤1：点击导入按钮
            import_btn = await self.click_import_button()
            if not import_btn:
                result['message'] = "未找到导入按钮"
                return result
            
            # 步骤2：处理文件选择
            await self.handle_file_selection(str(file_path))
            
            # 步骤3：确认上传
            await self.confirm_upload_dialog()
            
            # 步骤4：等待上传完成并获取URL
            success, url = await self.wait_for_upload_complete()
            
            if success:
                result['success'] = True
                result['url'] = url
                result['message'] = "上传成功"
                logger.info(f"✅ 上传成功: {url}")
            else:
                result['message'] = "上传超时或失败"
                
        except Exception as e:
            result['message'] = f"上传异常: {str(e)}"
            logger.error(f"❌ 上传异常: {e}")
            
        return result
    
    async def click_import_button(self) -> bool:
        """
        点击导入按钮
        
        使用多个选择器确保找到按钮
        
        Returns:
            bool: 是否成功点击
        """
        import_selectors = [
            'button.desktop-import-button-pc',  # 类选择器（最准确）
            'nav button:has(i.desktop-icon-import)',  # 图标选择器
            'button:has-text("导入")',  # 文本选择器
        ]
        
        for selector in import_selectors:
            try:
                btn = await self.page.wait_for_selector(selector, timeout=3000)
                if btn:
                    await btn.click()
                    logger.info(f"✅ 点击导入按钮: {selector}")
                    return True
            except:
                continue
                
        logger.error("❌ 未找到导入按钮")
        return False
    
    async def handle_file_selection(self, file_path: str):
        """
        处理文件选择
        
        两种方式：
        1. 直接设置input[type="file"]
        2. 使用filechooser API
        
        Args:
            file_path: 文件绝对路径
        """
        # 等待一下让文件选择器准备好
        await self.page.wait_for_timeout(1000)
        
        # 方式1：查找file input
        file_inputs = await self.page.query_selector_all('input[type="file"]')
        
        if file_inputs:
            # 使用最后一个（通常是最新的）
            await file_inputs[-1].set_input_files(file_path)
            logger.info(f"✅ 通过input选择文件: {file_path}")
        else:
            # 方式2：使用filechooser
            logger.info("使用filechooser选择文件")
            async with self.page.expect_file_chooser() as fc_info:
                # 重新触发文件选择器
                await self.click_import_button()
            
            file_chooser = await fc_info.value
            await file_chooser.set_files(file_path)
            logger.info(f"✅ 通过filechooser选择文件: {file_path}")
    
    async def confirm_upload_dialog(self):
        """
        确认上传对话框
        
        处理"导入本地文件"弹窗
        """
        try:
            # 等待弹窗出现
            await self.page.wait_for_timeout(2000)
            
            # 检查弹窗
            modal = await self.page.query_selector('.import-kit-import-modal-title:has-text("导入本地文件")')
            if modal:
                logger.info("✅ 导入弹窗已出现")
            
            # 点击确定按钮
            confirm_selectors = [
                'button.dui-button-type-primary:has-text("确定")',
                '.import-kit-import-file-footer button.dui-button-type-primary',
                'button.dui-button-type-primary .dui-button-container:has-text("确定")'
            ]
            
            for selector in confirm_selectors:
                try:
                    btn = await self.page.wait_for_selector(selector, timeout=2000)
                    if btn:
                        await btn.click()
                        logger.info("✅ 点击确定按钮")
                        return
                except:
                    continue
            
            # 备用方案：按Enter键
            await self.page.keyboard.press('Enter')
            logger.info("✅ 使用Enter键确认")
            
        except Exception as e:
            logger.warning(f"⚠️ 确认对话框处理: {e}")
    
    async def wait_for_upload_complete(self, timeout: int = 30) -> tuple:
        """
        等待上传完成
        
        判断标准：URL变化到文档页面
        
        Args:
            timeout: 超时时间（秒）
            
        Returns:
            tuple: (是否成功, 文档URL)
        """
        logger.info("⏳ 等待上传完成...")
        
        for _ in range(timeout // 5):
            await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            if '/sheet/' in current_url or '/doc/' in current_url or '/slide/' in current_url:
                return True, current_url
        
        return False, None
    
    async def cleanup(self):
        """清理资源"""
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        logger.info("🔚 资源已清理")


# ============= 使用示例 =============

async def main_example():
    """
    完整使用示例
    展示登录和上传的完整流程
    """
    
    # 配置
    COOKIE_FILE = 'config/cookies.json'
    TEST_FILE = '副本-副本-测试版本-出国销售计划表.xlsx'
    
    # 读取Cookie
    with open(COOKIE_FILE, 'r', encoding='utf-8') as f:
        config = json.load(f)
        cookie_string = config['cookie_string']
    
    # 使用上下文管理器自动管理资源
    async with TencentDocAutomation(headless=False) as automation:
        
        # 1. 登录
        login_success = await automation.login_with_cookies(cookie_string)
        if not login_success:
            logger.error("登录失败")
            return
        
        # 2. 上传文件
        result = await automation.upload_file(TEST_FILE)
        
        # 3. 处理结果
        if result['success']:
            print(f"\n✅ 上传成功！")
            print(f"📄 文档URL: {result['url']}")
        else:
            print(f"\n❌ 上传失败: {result['message']}")
        
        # 4. 保持浏览器打开供观察
        await asyncio.sleep(30)


# ============= 简化版本 =============

class SimpleTencentUploader:
    """
    简化版上传器
    最少代码实现核心功能
    """
    
    @staticmethod
    async def quick_upload(cookie_string: str, file_path: str) -> bool:
        """
        快速上传文件
        
        Args:
            cookie_string: Cookie字符串
            file_path: 文件路径
            
        Returns:
            bool: 是否成功
        """
        from playwright.async_api import async_playwright
        
        async with async_playwright() as p:
            # 启动浏览器
            browser = await p.chromium.launch(headless=False)
            context = await browser.new_context()
            page = await context.new_page()
            
            try:
                # 添加Cookie
                cookies = []
                for cookie_pair in cookie_string.split('; '):
                    if '=' in cookie_pair:
                        name, value = cookie_pair.split('=', 1)
                        cookies.append({
                            'name': name.strip(),
                            'value': value.strip(),
                            'domain': '.docs.qq.com',
                            'path': '/'
                        })
                await context.add_cookies(cookies)
                
                # 访问页面
                await page.goto('https://docs.qq.com/desktop/')
                await page.wait_for_timeout(5000)
                
                # 点击导入
                import_btn = await page.wait_for_selector('button.desktop-import-button-pc')
                await import_btn.click()
                
                # 选择文件
                await page.wait_for_timeout(1000)
                file_inputs = await page.query_selector_all('input[type="file"]')
                if file_inputs:
                    await file_inputs[-1].set_input_files(file_path)
                
                # 确认上传
                await page.wait_for_timeout(2000)
                confirm_btn = await page.query_selector('button.dui-button-type-primary:has-text("确定")')
                if confirm_btn:
                    await confirm_btn.click()
                
                # 等待完成
                await page.wait_for_timeout(10000)
                
                # 检查结果
                url = page.url
                return '/sheet/' in url or '/doc/' in url
                
            finally:
                await browser.close()


if __name__ == "__main__":
    # 运行示例
    asyncio.run(main_example())
```

---

## 🔧 关键技术点深度解析

### 1. Cookie处理的本质

Cookie字符串在浏览器中的格式：
```
name1=value1; name2=value2; name3=value3
```

注意每个Cookie之间是 `; `（分号+空格），而不是单独的分号。

**错误示例**：
```python
'fingerprint=xxx;low_login_enable=1'  # 紧凑格式
split(';')  # 结果：['fingerprint=xxx', 'low_login_enable=1']
```

**正确示例**：
```python
'fingerprint=xxx; low_login_enable=1'  # 标准格式
split('; ')  # 结果：['fingerprint=xxx', 'low_login_enable=1']
```

### 2. 页面访问策略

**为什么直接访问 `/desktop/`？**

- 主页 `https://docs.qq.com/` 会根据登录状态重定向
- 桌面页 `https://docs.qq.com/desktop/` 是登录后的默认页面
- 直接访问桌面页避免了重定向，更稳定

### 3. 文件选择的两种方式

**方式1：HTML5 File Input**
```python
file_input = await page.query_selector('input[type="file"]')
await file_input.set_input_files(file_path)
```

**方式2：Playwright FileChooser API**
```python
async with page.expect_file_chooser() as fc_info:
    await trigger_button.click()
file_chooser = await fc_info.value
await file_chooser.set_files(file_path)
```

腾讯文档可能动态创建file input，所以需要两种方式都准备。

### 4. 等待策略的重要性

```python
# 关键等待点
await page.wait_for_timeout(5000)  # 登录后等待
await page.wait_for_timeout(1000)  # 点击按钮后等待
await page.wait_for_timeout(2000)  # 弹窗出现等待
```

这些等待不是随意的，而是基于：
- 页面异步加载
- React/Vue组件渲染
- 网络请求完成

---

## 📊 成功率提升技巧

### 1. 多重选择器策略
```python
selectors = [
    'button.desktop-import-button-pc',  # 精确类名
    'nav button:has(i.desktop-icon-import)',  # 结构选择
    'button:has-text("导入")'  # 文本匹配
]
```

### 2. 错误重试机制
```python
async def retry_operation(func, max_retries=3):
    for i in range(max_retries):
        try:
            return await func()
        except Exception as e:
            if i == max_retries - 1:
                raise
            await asyncio.sleep(2 ** i)  # 指数退避
```

### 3. 状态验证链
```python
# 验证链
登录状态 → 按钮存在 → 文件选择 → 弹窗确认 → URL变化
```

---

## 🚀 快速开始指南

### 1. 安装依赖
```bash
pip install playwright
playwright install chromium
```

### 2. 获取Cookie
1. Chrome登录腾讯文档
2. F12 → Network → 刷新
3. 找到任意请求 → Headers → Cookie
4. 复制完整Cookie字符串

### 3. 配置文件
```json
{
  "cookie_string": "你的Cookie字符串"
}
```

### 4. 运行代码
```python
import asyncio
from your_script import SimpleTencentUploader

cookie = "你的Cookie"
file = "你的文件.xlsx"

asyncio.run(SimpleTencentUploader.quick_upload(cookie, file))
```

---

## ❓ 常见问题解决

### Q1: Cookie过期怎么办？
A: Cookie通常有效期7-30天，需要定期更新。可以实现自动检测和提醒机制。

### Q2: 文件选择失败？
A: 确保文件路径是绝对路径，使用 `Path(file).resolve()`

### Q3: 上传后没有跳转？
A: 可能是大文件处理时间长，增加等待时间。

### Q4: 如何批量上传？
A: 循环调用upload_file方法，每次上传后等待几秒。

---

## 📈 性能优化建议

1. **并发限制**：不要同时开多个浏览器实例
2. **资源清理**：使用完及时关闭浏览器
3. **缓存利用**：可以保持context复用
4. **日志优化**：生产环境减少日志输出

---

## 🎯 核心要点总结

1. **Cookie处理**：必须用 `'; '` 分割，只设置 `.docs.qq.com` 域
2. **访问流程**：直接访问 `/desktop/` 页面
3. **等待策略**：充分等待页面加载（5秒）
4. **选择器策略**：使用多个选择器提高成功率
5. **文件处理**：支持两种文件选择方式
6. **状态验证**：通过URL变化判断上传成功

这套方案经过实际验证，成功率高，可以直接用于生产环境。
# AIé˜…è¯»å¼•å¯¼ç³»ç»Ÿ - æ”¹è¿›å®æ–½æ–¹æ¡ˆ
> åˆ¶å®šæ—¶é—´ï¼š2025-08-31
> æ‰§è¡Œå‘¨æœŸï¼š3å¤©é€Ÿæˆè®¡åˆ’
> ç›®æ ‡ï¼šæ¢å¤AIåˆ†æåŠŸèƒ½ï¼Œæå‡ç³»ç»Ÿå¯ç”¨æ€§

## å¿«é€Ÿä¿®å¤æ¸…å•ï¼ˆç¬¬1å¤©ï¼‰

### ä¸Šåˆä»»åŠ¡ï¼ˆ2å°æ—¶ï¼‰

#### 1. APIå¯†é’¥é…ç½® [ç´§æ€¥]
```bash
# æ­¥éª¤1ï¼šåˆ›å»ºå¯†é’¥é…ç½®æ–‡ä»¶
cat > /root/projects/tencent-doc-manager/claude_mini_wrapper/.env << 'EOF'
# Claude APIé…ç½®
ANTHROPIC_API_KEY=sk-your-actual-key-here
ANTHROPIC_BASE_URL=https://code2.ppchat.vip
MAX_RETRIES=3
TIMEOUT=30
EOF

# æ­¥éª¤2ï¼šä¿®æ”¹config.pyæ”¯æŒ.envæ–‡ä»¶
# æ·»åŠ python-dotenvæ”¯æŒ
pip3 install python-dotenv
```

#### 2. æ·»åŠ é™çº§æœºåˆ¶
```python
# åˆ›å»ºæœ¬åœ°è§„åˆ™å¼•æ“ fallback_analyzer.py
class FallbackAnalyzer:
    """æœ¬åœ°è§„åˆ™åˆ†æå™¨ - APIä¸å¯ç”¨æ—¶çš„é™çº§æ–¹æ¡ˆ"""
    
    RISK_RULES = {
        "è´Ÿè´£äºº": {"level": "L2", "confidence": 0.8},
        "é‡‘é¢": {"level": "L1", "confidence": 0.9},
        "è¿›åº¦": {"level": "L3", "confidence": 0.7}
    }
    
    def analyze(self, column, old_value, new_value):
        """åŸºäºè§„åˆ™çš„æœ¬åœ°åˆ†æ"""
        if column in self.RISK_RULES:
            rule = self.RISK_RULES[column]
            return {
                "risk_level": rule["level"],
                "confidence": rule["confidence"],
                "recommendation": self._get_recommendation(rule["level"]),
                "source": "local_rules"
            }
        return self._default_analysis()
```

#### 3. Cookieè®¤è¯ä¿®å¤
```python
# æ›´æ–°è®¤è¯æœºåˆ¶
def refresh_cookie():
    """è‡ªåŠ¨åˆ·æ–°è…¾è®¯æ–‡æ¡£Cookie"""
    # æ–¹æ¡ˆ1ï¼šä½¿ç”¨seleniumè‡ªåŠ¨ç™»å½•
    # æ–¹æ¡ˆ2ï¼šç›‘å¬Cookieæ–‡ä»¶å˜åŒ–
    # æ–¹æ¡ˆ3ï¼šå®šæ—¶æé†’æ‰‹åŠ¨æ›´æ–°
    pass
```

### ä¸‹åˆä»»åŠ¡ï¼ˆ3å°æ—¶ï¼‰

#### 4. é”™è¯¯å¤„ç†ä¼˜åŒ–
```python
# æ”¹è¿›é”™è¯¯å“åº” error_handler.py
ERROR_MESSAGES = {
    "AUTH_001": "APIå¯†é’¥æœªé…ç½®ï¼Œè¯·è®¾ç½®ANTHROPIC_API_KEY",
    "AUTH_002": "Cookieå·²è¿‡æœŸï¼Œè¯·æ›´æ–°è®¤è¯ä¿¡æ¯",
    "API_503": "ä¸Šæ¸¸æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œå·²åˆ‡æ¢åˆ°æœ¬åœ°åˆ†æ",
    "API_LIMIT": "APIè°ƒç”¨æ¬¡æ•°è¶…é™ï¼Œè¯·ç¨åé‡è¯•"
}

def handle_api_error(error_code):
    message = ERROR_MESSAGES.get(error_code, "æœªçŸ¥é”™è¯¯")
    fallback_result = use_fallback_analysis()
    return {
        "status": "degraded",
        "message": message,
        "result": fallback_result
    }
```

#### 5. ç›‘æ§å‘Šè­¦éƒ¨ç½²
```bash
# åˆ›å»ºç®€å•ç›‘æ§è„šæœ¬
cat > /root/projects/tencent-doc-manager/monitor.sh << 'EOF'
#!/bin/bash
# æœåŠ¡ç›‘æ§è„šæœ¬

check_service() {
    local port=$1
    local name=$2
    if lsof -i :$port > /dev/null 2>&1; then
        echo "âœ… $name (ç«¯å£ $port) æ­£å¸¸"
    else
        echo "âŒ $name (ç«¯å£ $port) å¼‚å¸¸"
        # å‘é€å‘Šè­¦ï¼ˆé‚®ä»¶/webhookï¼‰
    fi
}

check_api() {
    response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/health)
    if [ "$response" = "200" ]; then
        echo "âœ… Claude API å¥åº·"
    else
        echo "âŒ Claude API å¼‚å¸¸ (HTTP $response)"
    fi
}

# æ‰§è¡Œæ£€æŸ¥
check_service 8081 "Claude Wrapper"
check_service 8089 "çƒ­åŠ›å›¾æœåŠ¡"
check_api
EOF

chmod +x monitor.sh
```

## åŠŸèƒ½å¢å¼ºï¼ˆç¬¬2å¤©ï¼‰

### ä¸Šåˆï¼šç¼“å­˜ä¼˜åŒ–
```python
# å®ç°æ™ºèƒ½ç¼“å­˜ cache_manager.py
import hashlib
import json
import time
from typing import Dict, Any

class SmartCache:
    def __init__(self, ttl=3600):
        self.cache = {}
        self.ttl = ttl
    
    def get_key(self, params: Dict[str, Any]) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        return hashlib.md5(
            json.dumps(params, sort_keys=True).encode()
        ).hexdigest()
    
    def get(self, params: Dict[str, Any]):
        """è·å–ç¼“å­˜ç»“æœ"""
        key = self.get_key(params)
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['timestamp'] < self.ttl:
                return entry['data']
        return None
    
    def set(self, params: Dict[str, Any], data: Any):
        """è®¾ç½®ç¼“å­˜"""
        key = self.get_key(params)
        self.cache[key] = {
            'data': data,
            'timestamp': time.time()
        }
```

### ä¸‹åˆï¼šæ‰¹é‡å¤„ç†ä¼˜åŒ–
```python
# æ‰¹é‡åˆ†æä¼˜åŒ– batch_processor.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

class BatchProcessor:
    def __init__(self, max_workers=5):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_batch(self, items):
        """å¹¶è¡Œå¤„ç†æ‰¹é‡è¯·æ±‚"""
        tasks = []
        for item in items:
            task = asyncio.create_task(self.process_single(item))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return self.merge_results(results)
```

## ç³»ç»ŸåŠ å›ºï¼ˆç¬¬3å¤©ï¼‰

### å®‰å…¨å¢å¼º
```python
# å®‰å…¨é…ç½® security.py
import secrets
from cryptography.fernet import Fernet

class SecurityManager:
    def __init__(self):
        self.cipher = Fernet(self.load_or_generate_key())
    
    def encrypt_api_key(self, api_key: str) -> bytes:
        """åŠ å¯†APIå¯†é’¥"""
        return self.cipher.encrypt(api_key.encode())
    
    def decrypt_api_key(self, encrypted: bytes) -> str:
        """è§£å¯†APIå¯†é’¥"""
        return self.cipher.decrypt(encrypted).decode()
    
    def load_or_generate_key(self):
        """åŠ è½½æˆ–ç”ŸæˆåŠ å¯†å¯†é’¥"""
        key_file = '.encryption_key'
        try:
            with open(key_file, 'rb') as f:
                return f.read()
        except FileNotFoundError:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
```

### æ€§èƒ½ä¼˜åŒ–
```python
# è¿æ¥æ± ä¼˜åŒ– connection_pool.py
import aiohttp
from aiohttp import TCPConnector

class OptimizedClient:
    def __init__(self):
        self.connector = TCPConnector(
            limit=100,
            limit_per_host=30,
            ttl_dns_cache=300,
            enable_cleanup_closed=True
        )
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            connector=self.connector,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        return self
    
    async def __aexit__(self, *args):
        await self.session.close()
```

## æµ‹è¯•éªŒè¯è®¡åˆ’

### å•å…ƒæµ‹è¯•
```python
# test_improvements.py
import pytest
import asyncio

@pytest.mark.asyncio
async def test_fallback_analyzer():
    """æµ‹è¯•é™çº§åˆ†æå™¨"""
    analyzer = FallbackAnalyzer()
    result = analyzer.analyze("è´Ÿè´£äºº", "å¼ ä¸‰", "æå››")
    assert result["risk_level"] == "L2"
    assert result["source"] == "local_rules"

@pytest.mark.asyncio  
async def test_cache_manager():
    """æµ‹è¯•ç¼“å­˜ç®¡ç†å™¨"""
    cache = SmartCache(ttl=1)
    params = {"column": "test", "value": "data"}
    cache.set(params, {"result": "cached"})
    
    # ç«‹å³è·å–åº”è¯¥å‘½ä¸­
    assert cache.get(params) is not None
    
    # ç­‰å¾…è¿‡æœŸ
    await asyncio.sleep(1.1)
    assert cache.get(params) is None

def test_error_handling():
    """æµ‹è¯•é”™è¯¯å¤„ç†"""
    result = handle_api_error("AUTH_001")
    assert "APIå¯†é’¥æœªé…ç½®" in result["message"]
    assert result["status"] == "degraded"
```

### é›†æˆæµ‹è¯•
```bash
# ç«¯åˆ°ç«¯æµ‹è¯•è„šæœ¬
#!/bin/bash
echo "=== AIç³»ç»Ÿé›†æˆæµ‹è¯• ==="

# 1. å¯åŠ¨æ‰€æœ‰æœåŠ¡
./start_all_services.sh

# 2. ç­‰å¾…æœåŠ¡å°±ç»ª
sleep 5

# 3. æ‰§è¡Œæµ‹è¯•å¥—ä»¶
python3 -m pytest tests/ -v

# 4. æ€§èƒ½æµ‹è¯•
ab -n 100 -c 10 http://localhost:8081/health

# 5. ç”ŸæˆæŠ¥å‘Š
python3 generate_test_report.py
```

## éƒ¨ç½²æµç¨‹

### è‡ªåŠ¨åŒ–éƒ¨ç½²è„šæœ¬
```bash
#!/bin/bash
# deploy.sh - ä¸€é”®éƒ¨ç½²è„šæœ¬

set -e  # é‡é”™å³åœ

echo "ğŸš€ å¼€å§‹éƒ¨ç½²AIç³»ç»Ÿæ”¹è¿›..."

# 1. å¤‡ä»½å½“å‰ç‰ˆæœ¬
echo "ğŸ“¦ å¤‡ä»½å½“å‰ç‰ˆæœ¬..."
tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz claude_mini_wrapper/

# 2. å®‰è£…ä¾èµ–
echo "ğŸ“š å®‰è£…ä¾èµ–..."
pip3 install -r requirements.txt

# 3. åº”ç”¨é…ç½®
echo "âš™ï¸ åº”ç”¨é…ç½®..."
cp .env.example .env
echo "è¯·ç¼–è¾‘ .env æ–‡ä»¶è®¾ç½®APIå¯†é’¥"

# 4. é‡å¯æœåŠ¡
echo "â™»ï¸ é‡å¯æœåŠ¡..."
systemctl restart claude-wrapper
systemctl restart heatmap-server

# 5. éªŒè¯éƒ¨ç½²
echo "âœ… éªŒè¯éƒ¨ç½²..."
sleep 3
curl http://localhost:8081/health

echo "ğŸ‰ éƒ¨ç½²å®Œæˆ!"
```

## ç»´æŠ¤è®¡åˆ’

### æ—¥å¸¸ç»´æŠ¤ä»»åŠ¡
- **æ¯æ—¥**ï¼šæ£€æŸ¥æœåŠ¡çŠ¶æ€ï¼ŒæŸ¥çœ‹é”™è¯¯æ—¥å¿—
- **æ¯å‘¨**ï¼šåˆ†ææ€§èƒ½æŒ‡æ ‡ï¼Œä¼˜åŒ–æ…¢æŸ¥è¯¢
- **æ¯æœˆ**ï¼šæ›´æ–°ä¾èµ–åŒ…ï¼Œå®‰å…¨æ‰«æ

### ç›‘æ§æŒ‡æ ‡
```python
# å…³é”®æŒ‡æ ‡å®šä¹‰
METRICS = {
    "api_success_rate": {"threshold": 0.95, "alert": "email"},
    "response_time_p99": {"threshold": 10.0, "alert": "slack"},
    "memory_usage": {"threshold": 2048, "alert": "log"},
    "cache_hit_rate": {"threshold": 0.6, "alert": "log"}
}
```

## æˆåŠŸæ ‡å‡†

### ç¬¬1å¤©å®Œæˆ
- [ ] APIå¯ä»¥æ­£å¸¸è°ƒç”¨
- [ ] é™çº§æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] é”™è¯¯ä¿¡æ¯æ¸…æ™°æ˜ç¡®

### ç¬¬2å¤©å®Œæˆ
- [ ] ç¼“å­˜å‘½ä¸­ç‡>60%
- [ ] æ‰¹é‡å¤„ç†æ€§èƒ½æå‡50%
- [ ] ç›‘æ§å‘Šè­¦ç³»ç»Ÿè¿è¡Œ

### ç¬¬3å¤©å®Œæˆ
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ–‡æ¡£æ›´æ–°å®Œæ•´
- [ ] ç”Ÿäº§ç¯å¢ƒå°±ç»ª

## é£é™©ç®¡ç†

| é£é™© | ç¼“è§£æªæ–½ |
|------|----------|
| APIå¯†é’¥æ³„éœ² | åŠ å¯†å­˜å‚¨ï¼Œå®šæœŸè½®æ¢ |
| æœåŠ¡ä¸­æ–­ | é™çº§æœºåˆ¶ï¼Œæœ¬åœ°åˆ†æ |
| æ€§èƒ½ç“¶é¢ˆ | ç¼“å­˜ä¼˜åŒ–ï¼Œå¼‚æ­¥å¤„ç† |
| æ•°æ®ä¸ä¸€è‡´ | äº‹åŠ¡ä¿è¯ï¼Œæ•°æ®æ ¡éªŒ |

---
*å®æ–½è´Ÿè´£äººï¼šDevOpså›¢é˜Ÿ*
*é¢„è®¡å®Œæˆæ—¶é—´ï¼š3ä¸ªå·¥ä½œæ—¥*
*æœ€åæ›´æ–°ï¼š2025-08-31*
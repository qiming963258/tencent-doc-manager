# AI阅读引导系统 - 改进实施方案
> 制定时间：2025-08-31
> 执行周期：3天速成计划
> 目标：恢复AI分析功能，提升系统可用性

## 快速修复清单（第1天）

### 上午任务（2小时）

#### 1. API密钥配置 [紧急]
```bash
# 步骤1：创建密钥配置文件
cat > /root/projects/tencent-doc-manager/claude_mini_wrapper/.env << 'EOF'
# Claude API配置
ANTHROPIC_API_KEY=sk-your-actual-key-here
ANTHROPIC_BASE_URL=https://code2.ppchat.vip
MAX_RETRIES=3
TIMEOUT=30
EOF

# 步骤2：修改config.py支持.env文件
# 添加python-dotenv支持
pip3 install python-dotenv
```

#### 2. 添加降级机制
```python
# 创建本地规则引擎 fallback_analyzer.py
class FallbackAnalyzer:
    """本地规则分析器 - API不可用时的降级方案"""
    
    RISK_RULES = {
        "负责人": {"level": "L2", "confidence": 0.8},
        "金额": {"level": "L1", "confidence": 0.9},
        "进度": {"level": "L3", "confidence": 0.7}
    }
    
    def analyze(self, column, old_value, new_value):
        """基于规则的本地分析"""
        if column in self.RISK_RULES:
            rule = self.RISK_RULES[column]
            return {
                "risk_level": rule["level"],
                "confidence": rule["confidence"],
                "recommendation": self._get_recommendation(rule["level"]),
                "source": "local_rules"
            }
        return self._default_analysis()
```

#### 3. Cookie认证修复
```python
# 更新认证机制
def refresh_cookie():
    """自动刷新腾讯文档Cookie"""
    # 方案1：使用selenium自动登录
    # 方案2：监听Cookie文件变化
    # 方案3：定时提醒手动更新
    pass
```

### 下午任务（3小时）

#### 4. 错误处理优化
```python
# 改进错误响应 error_handler.py
ERROR_MESSAGES = {
    "AUTH_001": "API密钥未配置，请设置ANTHROPIC_API_KEY",
    "AUTH_002": "Cookie已过期，请更新认证信息",
    "API_503": "上游服务暂时不可用，已切换到本地分析",
    "API_LIMIT": "API调用次数超限，请稍后重试"
}

def handle_api_error(error_code):
    message = ERROR_MESSAGES.get(error_code, "未知错误")
    fallback_result = use_fallback_analysis()
    return {
        "status": "degraded",
        "message": message,
        "result": fallback_result
    }
```

#### 5. 监控告警部署
```bash
# 创建简单监控脚本
cat > /root/projects/tencent-doc-manager/monitor.sh << 'EOF'
#!/bin/bash
# 服务监控脚本

check_service() {
    local port=$1
    local name=$2
    if lsof -i :$port > /dev/null 2>&1; then
        echo "✅ $name (端口 $port) 正常"
    else
        echo "❌ $name (端口 $port) 异常"
        # 发送告警（邮件/webhook）
    fi
}

check_api() {
    response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/health)
    if [ "$response" = "200" ]; then
        echo "✅ Claude API 健康"
    else
        echo "❌ Claude API 异常 (HTTP $response)"
    fi
}

# 执行检查
check_service 8081 "Claude Wrapper"
check_service 8089 "热力图服务"
check_api
EOF

chmod +x monitor.sh
```

## 功能增强（第2天）

### 上午：缓存优化
```python
# 实现智能缓存 cache_manager.py
import hashlib
import json
import time
from typing import Dict, Any

class SmartCache:
    def __init__(self, ttl=3600):
        self.cache = {}
        self.ttl = ttl
    
    def get_key(self, params: Dict[str, Any]) -> str:
        """生成缓存键"""
        return hashlib.md5(
            json.dumps(params, sort_keys=True).encode()
        ).hexdigest()
    
    def get(self, params: Dict[str, Any]):
        """获取缓存结果"""
        key = self.get_key(params)
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['timestamp'] < self.ttl:
                return entry['data']
        return None
    
    def set(self, params: Dict[str, Any], data: Any):
        """设置缓存"""
        key = self.get_key(params)
        self.cache[key] = {
            'data': data,
            'timestamp': time.time()
        }
```

### 下午：批量处理优化
```python
# 批量分析优化 batch_processor.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

class BatchProcessor:
    def __init__(self, max_workers=5):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_batch(self, items):
        """并行处理批量请求"""
        tasks = []
        for item in items:
            task = asyncio.create_task(self.process_single(item))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return self.merge_results(results)
```

## 系统加固（第3天）

### 安全增强
```python
# 安全配置 security.py
import secrets
from cryptography.fernet import Fernet

class SecurityManager:
    def __init__(self):
        self.cipher = Fernet(self.load_or_generate_key())
    
    def encrypt_api_key(self, api_key: str) -> bytes:
        """加密API密钥"""
        return self.cipher.encrypt(api_key.encode())
    
    def decrypt_api_key(self, encrypted: bytes) -> str:
        """解密API密钥"""
        return self.cipher.decrypt(encrypted).decode()
    
    def load_or_generate_key(self):
        """加载或生成加密密钥"""
        key_file = '.encryption_key'
        try:
            with open(key_file, 'rb') as f:
                return f.read()
        except FileNotFoundError:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
```

### 性能优化
```python
# 连接池优化 connection_pool.py
import aiohttp
from aiohttp import TCPConnector

class OptimizedClient:
    def __init__(self):
        self.connector = TCPConnector(
            limit=100,
            limit_per_host=30,
            ttl_dns_cache=300,
            enable_cleanup_closed=True
        )
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            connector=self.connector,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        return self
    
    async def __aexit__(self, *args):
        await self.session.close()
```

## 测试验证计划

### 单元测试
```python
# test_improvements.py
import pytest
import asyncio

@pytest.mark.asyncio
async def test_fallback_analyzer():
    """测试降级分析器"""
    analyzer = FallbackAnalyzer()
    result = analyzer.analyze("负责人", "张三", "李四")
    assert result["risk_level"] == "L2"
    assert result["source"] == "local_rules"

@pytest.mark.asyncio  
async def test_cache_manager():
    """测试缓存管理器"""
    cache = SmartCache(ttl=1)
    params = {"column": "test", "value": "data"}
    cache.set(params, {"result": "cached"})
    
    # 立即获取应该命中
    assert cache.get(params) is not None
    
    # 等待过期
    await asyncio.sleep(1.1)
    assert cache.get(params) is None

def test_error_handling():
    """测试错误处理"""
    result = handle_api_error("AUTH_001")
    assert "API密钥未配置" in result["message"]
    assert result["status"] == "degraded"
```

### 集成测试
```bash
# 端到端测试脚本
#!/bin/bash
echo "=== AI系统集成测试 ==="

# 1. 启动所有服务
./start_all_services.sh

# 2. 等待服务就绪
sleep 5

# 3. 执行测试套件
python3 -m pytest tests/ -v

# 4. 性能测试
ab -n 100 -c 10 http://localhost:8081/health

# 5. 生成报告
python3 generate_test_report.py
```

## 部署流程

### 自动化部署脚本
```bash
#!/bin/bash
# deploy.sh - 一键部署脚本

set -e  # 遇错即停

echo "🚀 开始部署AI系统改进..."

# 1. 备份当前版本
echo "📦 备份当前版本..."
tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz claude_mini_wrapper/

# 2. 安装依赖
echo "📚 安装依赖..."
pip3 install -r requirements.txt

# 3. 应用配置
echo "⚙️ 应用配置..."
cp .env.example .env
echo "请编辑 .env 文件设置API密钥"

# 4. 重启服务
echo "♻️ 重启服务..."
systemctl restart claude-wrapper
systemctl restart heatmap-server

# 5. 验证部署
echo "✅ 验证部署..."
sleep 3
curl http://localhost:8081/health

echo "🎉 部署完成!"
```

## 维护计划

### 日常维护任务
- **每日**：检查服务状态，查看错误日志
- **每周**：分析性能指标，优化慢查询
- **每月**：更新依赖包，安全扫描

### 监控指标
```python
# 关键指标定义
METRICS = {
    "api_success_rate": {"threshold": 0.95, "alert": "email"},
    "response_time_p99": {"threshold": 10.0, "alert": "slack"},
    "memory_usage": {"threshold": 2048, "alert": "log"},
    "cache_hit_rate": {"threshold": 0.6, "alert": "log"}
}
```

## 成功标准

### 第1天完成
- [ ] API可以正常调用
- [ ] 降级机制正常工作
- [ ] 错误信息清晰明确

### 第2天完成
- [ ] 缓存命中率>60%
- [ ] 批量处理性能提升50%
- [ ] 监控告警系统运行

### 第3天完成
- [ ] 所有测试通过
- [ ] 文档更新完整
- [ ] 生产环境就绪

## 风险管理

| 风险 | 缓解措施 |
|------|----------|
| API密钥泄露 | 加密存储，定期轮换 |
| 服务中断 | 降级机制，本地分析 |
| 性能瓶颈 | 缓存优化，异步处理 |
| 数据不一致 | 事务保证，数据校验 |

---
*实施负责人：DevOps团队*
*预计完成时间：3个工作日*
*最后更新：2025-08-31*